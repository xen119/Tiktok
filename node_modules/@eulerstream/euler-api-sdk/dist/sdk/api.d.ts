/**
 * The Sign Serverâ„¢
 * Sign Server API Documentation
 *
 * The version of the OpenAPI document: dev
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import type { RequestArgs } from './base';
import { BaseAPI } from './base';
/**
 *
 * @export
 * @interface Account
 */
export interface Account {
    /**
     *
     * @type {number}
     * @memberof Account
     */
    'day': number;
    /**
     *
     * @type {number}
     * @memberof Account
     */
    'hour': number;
    /**
     *
     * @type {number}
     * @memberof Account
     */
    'minute': number;
    /**
     *
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof Account
     */
    'webhook_secret': string;
    /**
     *
     * @type {number}
     * @memberof Account
     */
    'max_alerts': number;
    /**
     *
     * @type {number}
     * @memberof Account
     */
    'max_websockets': number;
    /**
     *
     * @type {string}
     * @memberof Account
     */
    'expires_at': string | null;
    /**
     *
     * @type {number}
     * @memberof Account
     */
    'purchased_captcha_credits': number;
    /**
     *
     * @type {number}
     * @memberof Account
     */
    'extra_captcha_credits': number;
    /**
     *
     * @type {string}
     * @memberof Account
     */
    'updated_at': string;
    /**
     *
     * @type {string}
     * @memberof Account
     */
    'created_at': string;
    /**
     *
     * @type {number}
     * @memberof Account
     */
    'id': number;
}
/**
 *
 * @export
 * @interface AccountConfig
 */
export interface AccountConfig {
    /**
     *
     * @type {number}
     * @memberof AccountConfig
     */
    'day': number;
    /**
     *
     * @type {number}
     * @memberof AccountConfig
     */
    'hour': number;
    /**
     *
     * @type {number}
     * @memberof AccountConfig
     */
    'minute': number;
    /**
     *
     * @type {string}
     * @memberof AccountConfig
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof AccountConfig
     */
    'webhook_secret': string;
    /**
     *
     * @type {number}
     * @memberof AccountConfig
     */
    'max_alerts': number;
    /**
     *
     * @type {number}
     * @memberof AccountConfig
     */
    'max_websockets': number;
    /**
     *
     * @type {string}
     * @memberof AccountConfig
     */
    'expires_at': string | null;
}
/**
 *
 * @export
 * @enum {number}
 */
export declare const AccountScopes: {
    readonly NUMBER_MINUS_1: -1;
    readonly NUMBER_0: 0;
    readonly NUMBER_1: 1;
    readonly NUMBER_3: 3;
    readonly NUMBER_10: 10;
    readonly NUMBER_11: 11;
    readonly NUMBER_8: 8;
    readonly NUMBER_6: 6;
    readonly NUMBER_12: 12;
    readonly NUMBER_13: 13;
    readonly NUMBER_14: 14;
    readonly NUMBER_15: 15;
};
export type AccountScopes = typeof AccountScopes[keyof typeof AccountScopes];
/**
 *
 * @export
 * @interface AccountWithPermissionsSafe
 */
export interface AccountWithPermissionsSafe {
    /**
     *
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'day': number;
    /**
     *
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'hour': number;
    /**
     *
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'minute': number;
    /**
     *
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'webhook_secret': string;
    /**
     *
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'max_alerts': number;
    /**
     *
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'max_websockets': number;
    /**
     *
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'expires_at': string | null;
    /**
     *
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'purchased_captcha_credits': number;
    /**
     *
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'extra_captcha_credits': number;
    /**
     *
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'updated_at': string;
    /**
     *
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'created_at': string;
    /**
     *
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'id': number;
    /**
     *
     * @type {Array<AccountScopes>}
     * @memberof AccountWithPermissionsSafe
     */
    'scopes': Array<AccountScopes>;
}
/**
 *
 * @export
 * @interface AccountsTableRequestLimits
 */
export interface AccountsTableRequestLimits {
    /**
     *
     * @type {number}
     * @memberof AccountsTableRequestLimits
     */
    'day': number;
    /**
     *
     * @type {number}
     * @memberof AccountsTableRequestLimits
     */
    'hour': number;
    /**
     *
     * @type {number}
     * @memberof AccountsTableRequestLimits
     */
    'minute': number;
}
/**
 *
 * @export
 * @interface Alert
 */
export interface Alert {
    /**
     *
     * @type {number}
     * @memberof Alert
     */
    'account_id': number;
    /**
     *
     * @type {number}
     * @memberof Alert
     */
    'alert_creator_id': number;
    /**
     *
     * @type {boolean}
     * @memberof Alert
     */
    'read_only': boolean;
    /**
     *
     * @type {string}
     * @memberof Alert
     */
    'alert_creator_nickname': string | null;
    /**
     *
     * @type {string}
     * @memberof Alert
     */
    'alert_creator_avatar_url': string | null;
    /**
     *
     * @type {string}
     * @memberof Alert
     */
    'alert_creator_username': string;
    /**
     *
     * @type {string}
     * @memberof Alert
     */
    'created_at': string;
    /**
     *
     * @type {number}
     * @memberof Alert
     */
    'id': number;
}
/**
 *
 * @export
 * @interface AlertConfig
 */
export interface AlertConfig {
    /**
     *
     * @type {number}
     * @memberof AlertConfig
     */
    'account_id': number;
    /**
     *
     * @type {number}
     * @memberof AlertConfig
     */
    'alert_creator_id': number;
    /**
     *
     * @type {boolean}
     * @memberof AlertConfig
     */
    'read_only': boolean;
}
/**
 *
 * @export
 * @interface AlertTarget
 */
export interface AlertTarget {
    /**
     *
     * @type {string}
     * @memberof AlertTarget
     */
    'url': string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof AlertTarget
     */
    'metadata': {
        [key: string]: any;
    };
    /**
     *
     * @type {number}
     * @memberof AlertTarget
     */
    'alert_id': number;
    /**
     *
     * @type {number}
     * @memberof AlertTarget
     */
    'alert_creator_id': number;
    /**
     *
     * @type {AlertTargetStatus}
     * @memberof AlertTarget
     */
    'last_status': AlertTargetStatus;
    /**
     *
     * @type {AlertTargetFormat}
     * @memberof AlertTarget
     */
    'format': AlertTargetFormat;
    /**
     *
     * @type {number}
     * @memberof AlertTarget
     */
    'account_id': number;
    /**
     *
     * @type {string}
     * @memberof AlertTarget
     */
    'updated_at': string;
    /**
     *
     * @type {string}
     * @memberof AlertTarget
     */
    'created_at': string;
    /**
     *
     * @type {number}
     * @memberof AlertTarget
     */
    'id': number;
}
/**
 *
 * @export
 * @interface AlertTargetConfig
 */
export interface AlertTargetConfig {
    /**
     *
     * @type {string}
     * @memberof AlertTargetConfig
     */
    'url': string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof AlertTargetConfig
     */
    'metadata': {
        [key: string]: any;
    };
    /**
     *
     * @type {number}
     * @memberof AlertTargetConfig
     */
    'alert_id': number;
    /**
     *
     * @type {number}
     * @memberof AlertTargetConfig
     */
    'alert_creator_id': number;
    /**
     *
     * @type {AlertTargetStatus}
     * @memberof AlertTargetConfig
     */
    'last_status': AlertTargetStatus;
    /**
     *
     * @type {AlertTargetFormat}
     * @memberof AlertTargetConfig
     */
    'format': AlertTargetFormat;
}
/**
 *
 * @export
 * @enum {number}
 */
export declare const AlertTargetFormat: {
    readonly NUMBER_1: 1;
};
export type AlertTargetFormat = typeof AlertTargetFormat[keyof typeof AlertTargetFormat];
/**
 *
 * @export
 * @enum {number}
 */
export declare const AlertTargetStatus: {
    readonly NUMBER_0: 0;
    readonly NUMBER_1: 1;
    readonly NUMBER_4: 4;
};
export type AlertTargetStatus = typeof AlertTargetStatus[keyof typeof AlertTargetStatus];
/**
 *
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     *
     * @type {string}
     * @memberof ApiKey
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof ApiKey
     */
    'value': string;
    /**
     *
     * @type {number}
     * @memberof ApiKey
     */
    'account_id': number;
    /**
     *
     * @type {string}
     * @memberof ApiKey
     */
    'updated_at': string;
    /**
     *
     * @type {string}
     * @memberof ApiKey
     */
    'created_at': string;
    /**
     *
     * @type {number}
     * @memberof ApiKey
     */
    'id': number;
}
/**
 *
 * @export
 * @interface ApiKeyConfig
 */
export interface ApiKeyConfig {
    /**
     *
     * @type {string}
     * @memberof ApiKeyConfig
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof ApiKeyConfig
     */
    'value': string;
    /**
     *
     * @type {number}
     * @memberof ApiKeyConfig
     */
    'account_id': number;
}
/**
 *
 * @export
 * @interface CaptchaCreditsResponse
 */
export interface CaptchaCreditsResponse {
    /**
     *
     * @type {number}
     * @memberof CaptchaCreditsResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof CaptchaCreditsResponse
     */
    'message'?: string;
    /**
     *
     * @type {number}
     * @memberof CaptchaCreditsResponse
     */
    'plan_credits': number;
    /**
     *
     * @type {number}
     * @memberof CaptchaCreditsResponse
     */
    'purchased_credits': number;
}
/**
 *
 * @export
 * @interface CountSignUsage
 */
export interface CountSignUsage {
    /**
     *
     * @type {number}
     * @memberof CountSignUsage
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof CountSignUsage
     */
    'message'?: string;
    /**
     *
     * @type {number}
     * @memberof CountSignUsage
     */
    'pages'?: number;
}
/**
 * Configuration for the alert
 * @export
 * @interface CreateAlertRequest
 */
export interface CreateAlertRequest {
    /**
     *
     * @type {string}
     * @memberof CreateAlertRequest
     */
    'unique_id': string;
}
/**
 *
 * @export
 * @interface CreateAlertResponse
 */
export interface CreateAlertResponse {
    /**
     *
     * @type {number}
     * @memberof CreateAlertResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof CreateAlertResponse
     */
    'message'?: string;
    /**
     *
     * @type {Alert}
     * @memberof CreateAlertResponse
     */
    'alert'?: Alert;
}
/**
 *
 * @export
 * @interface CreateAlertTargetPayload
 */
export interface CreateAlertTargetPayload {
    /**
     *
     * @type {string}
     * @memberof CreateAlertTargetPayload
     */
    'url': string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof CreateAlertTargetPayload
     */
    'metadata'?: {
        [key: string]: any;
    };
}
/**
 *
 * @export
 * @interface CreateAlertTargetResponse
 */
export interface CreateAlertTargetResponse {
    /**
     *
     * @type {number}
     * @memberof CreateAlertTargetResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof CreateAlertTargetResponse
     */
    'message'?: string;
    /**
     *
     * @type {AlertTarget}
     * @memberof CreateAlertTargetResponse
     */
    'target'?: AlertTarget;
}
/**
 *
 * @export
 * @interface CreateJWTResponse
 */
export interface CreateJWTResponse {
    /**
     *
     * @type {number}
     * @memberof CreateJWTResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof CreateJWTResponse
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof CreateJWTResponse
     */
    'token'?: string;
    /**
     *
     * @type {JWTConfig}
     * @memberof CreateJWTResponse
     */
    'config'?: JWTConfig;
}
/**
 *
 * @export
 * @interface CreateKeyPayload
 */
export interface CreateKeyPayload {
    /**
     *
     * @type {string}
     * @memberof CreateKeyPayload
     */
    'name': string;
}
/**
 *
 * @export
 * @interface CreateKeyResponse
 */
export interface CreateKeyResponse {
    /**
     *
     * @type {number}
     * @memberof CreateKeyResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof CreateKeyResponse
     */
    'message'?: string;
    /**
     *
     * @type {ApiKey}
     * @memberof CreateKeyResponse
     */
    'key'?: ApiKey;
}
/**
 *
 * @export
 * @interface DeleteAlertResponse
 */
export interface DeleteAlertResponse {
    /**
     *
     * @type {number}
     * @memberof DeleteAlertResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof DeleteAlertResponse
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface DeleteAlertTargetResponse
 */
export interface DeleteAlertTargetResponse {
    /**
     *
     * @type {number}
     * @memberof DeleteAlertTargetResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof DeleteAlertTargetResponse
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface DeleteKeyResponse
 */
export interface DeleteKeyResponse {
    /**
     *
     * @type {number}
     * @memberof DeleteKeyResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof DeleteKeyResponse
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface GetRateLimits
 */
export interface GetRateLimits {
    /**
     *
     * @type {number}
     * @memberof GetRateLimits
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof GetRateLimits
     */
    'message'?: string;
    /**
     *
     * @type {RateLimitInfo}
     * @memberof GetRateLimits
     */
    'day'?: RateLimitInfo;
    /**
     *
     * @type {RateLimitInfo}
     * @memberof GetRateLimits
     */
    'hour'?: RateLimitInfo;
    /**
     *
     * @type {RateLimitInfo}
     * @memberof GetRateLimits
     */
    'minute'?: RateLimitInfo;
    /**
     *
     * @type {LoadShedInfo}
     * @memberof GetRateLimits
     */
    'load_shedding': LoadShedInfo;
}
/**
 *
 * @export
 * @interface GetSignUsageResponse
 */
export interface GetSignUsageResponse {
    /**
     *
     * @type {number}
     * @memberof GetSignUsageResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof GetSignUsageResponse
     */
    'message'?: string;
    /**
     *
     * @type {Array<SignLogPublic>}
     * @memberof GetSignUsageResponse
     */
    'usage'?: Array<SignLogPublic>;
}
/**
 *
 * @export
 * @interface GetSignWebcastUrlResponse
 */
export interface GetSignWebcastUrlResponse {
    /**
     *
     * @type {number}
     * @memberof GetSignWebcastUrlResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'signedUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'msToken'?: string;
    /**
     *
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'browserVersion'?: string;
    /**
     *
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'browserName'?: string;
    /**
     *
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    '_signature'?: string;
    /**
     *
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'X-Bogus'?: string;
    /**
     *
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'User-Agent'?: string;
}
/**
 *
 * @export
 * @interface HostsResponse
 */
export interface HostsResponse {
    /**
     *
     * @type {number}
     * @memberof HostsResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof HostsResponse
     */
    'message'?: string;
    /**
     *
     * @type {Array<PeerPresence>}
     * @memberof HostsResponse
     */
    'hosts'?: Array<PeerPresence>;
}
/**
 *
 * @export
 * @interface IconCaptchaResponse
 */
export interface IconCaptchaResponse {
    /**
     *
     * @type {IconsResult}
     * @memberof IconCaptchaResponse
     */
    'response': IconsResult | null;
    /**
     *
     * @type {boolean}
     * @memberof IconCaptchaResponse
     */
    'cached': boolean;
    /**
     *
     * @type {number}
     * @memberof IconCaptchaResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IconCaptchaResponse
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface IconsResult
 */
export interface IconsResult {
    /**
     *
     * @type {number}
     * @memberof IconsResult
     */
    'time_ms': number;
    /**
     *
     * @type {Array<Point>}
     * @memberof IconsResult
     */
    'points': Array<Point>;
}
/**
 *
 * @export
 * @interface JSONResponse
 */
export interface JSONResponse {
    /**
     *
     * @type {number}
     * @memberof JSONResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof JSONResponse
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface JWTConfig
 */
export interface JWTConfig {
    /**
     *
     * @type {string}
     * @memberof JWTConfig
     */
    'id': string;
    /**
     *
     * @type {number}
     * @memberof JWTConfig
     */
    'expiresAt': number;
    /**
     *
     * @type {number}
     * @memberof JWTConfig
     */
    'ttl': number;
    /**
     *
     * @type {number}
     * @memberof JWTConfig
     */
    'accountId': number;
    /**
     *
     * @type {number}
     * @memberof JWTConfig
     */
    'apiKeyId': number;
    /**
     *
     * @type {AccountsTableRequestLimits}
     * @memberof JWTConfig
     */
    'limits': AccountsTableRequestLimits;
    /**
     *
     * @type {JWTConfigWebSocketData}
     * @memberof JWTConfig
     */
    'webSocketData': JWTConfigWebSocketData;
    /**
     *
     * @type {string}
     * @memberof JWTConfig
     */
    'name': string | null;
}
/**
 *
 * @export
 * @interface JWTConfigWebSocketData
 */
export interface JWTConfigWebSocketData {
    /**
     *
     * @type {string}
     * @memberof JWTConfigWebSocketData
     */
    'encryptedTtTargetIdc'?: string;
    /**
     *
     * @type {string}
     * @memberof JWTConfigWebSocketData
     */
    'encryptedSessionId'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof JWTConfigWebSocketData
     */
    'allowedCreators': Array<string> | null;
    /**
     *
     * @type {number}
     * @memberof JWTConfigWebSocketData
     */
    'maxWebSockets': number;
}
/**
 *
 * @export
 * @interface JWTCreateConfig
 */
export interface JWTCreateConfig {
    /**
     *
     * @type {AccountsTableRequestLimits}
     * @memberof JWTCreateConfig
     */
    'limits'?: AccountsTableRequestLimits | null;
    /**
     *
     * @type {JWTCreateConfigWebSocketData}
     * @memberof JWTCreateConfig
     */
    'websockets'?: JWTCreateConfigWebSocketData | null;
    /**
     *
     * @type {number}
     * @memberof JWTCreateConfig
     */
    'expireAfter': number;
    /**
     *
     * @type {string}
     * @memberof JWTCreateConfig
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface JWTCreateConfigWebSocketData
 */
export interface JWTCreateConfigWebSocketData {
    /**
     *
     * @type {string}
     * @memberof JWTCreateConfigWebSocketData
     */
    'ttTargetIdc'?: string;
    /**
     *
     * @type {string}
     * @memberof JWTCreateConfigWebSocketData
     */
    'sessionId'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof JWTCreateConfigWebSocketData
     */
    'allowedCreators': Array<string> | null;
    /**
     *
     * @type {number}
     * @memberof JWTCreateConfigWebSocketData
     */
    'maxWebSockets': number;
}
/**
 *
 * @export
 * @interface ListAlertTargetsResponse
 */
export interface ListAlertTargetsResponse {
    /**
     *
     * @type {number}
     * @memberof ListAlertTargetsResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof ListAlertTargetsResponse
     */
    'message'?: string;
    /**
     *
     * @type {Array<AlertTarget>}
     * @memberof ListAlertTargetsResponse
     */
    'targets'?: Array<AlertTarget>;
}
/**
 *
 * @export
 * @interface ListAlertsResponse
 */
export interface ListAlertsResponse {
    /**
     *
     * @type {number}
     * @memberof ListAlertsResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof ListAlertsResponse
     */
    'message'?: string;
    /**
     *
     * @type {Array<Alert>}
     * @memberof ListAlertsResponse
     */
    'alerts'?: Array<Alert>;
    /**
     *
     * @type {boolean}
     * @memberof ListAlertsResponse
     */
    'hasMore': boolean;
}
/**
 *
 * @export
 * @interface ListKeysResponse
 */
export interface ListKeysResponse {
    /**
     *
     * @type {number}
     * @memberof ListKeysResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof ListKeysResponse
     */
    'message'?: string;
    /**
     *
     * @type {Array<ApiKey>}
     * @memberof ListKeysResponse
     */
    'keys'?: Array<ApiKey>;
}
/**
 *
 * @export
 * @interface LoadShedInfo
 */
export interface LoadShedInfo {
    /**
     *
     * @type {number}
     * @memberof LoadShedInfo
     */
    'at': number;
    /**
     *
     * @type {number}
     * @memberof LoadShedInfo
     */
    'chance': number;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const OxyLabsProxyRegion: {
    readonly Us: "US";
    readonly Gb: "GB";
    readonly De: "DE";
    readonly Ro: "RO";
    readonly Es: "ES";
    readonly Be: "BE";
    readonly Fr: "FR";
    readonly Ca: "CA";
    readonly Jp: "JP";
    readonly Br: "BR";
    readonly Mx: "MX";
    readonly Co: "CO";
    readonly Ar: "AR";
    readonly Cl: "CL";
    readonly Au: "AU";
    readonly Kr: "KR";
    readonly Pe: "PE";
    readonly Pl: "PL";
    readonly Sg: "SG";
    readonly It: "IT";
};
export type OxyLabsProxyRegion = typeof OxyLabsProxyRegion[keyof typeof OxyLabsProxyRegion];
/**
 * Make all properties in T optional
 * @export
 * @interface PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
 */
export interface PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber {
    /**
     *
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'avatar_url'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'nickname'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'sec_uid'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'numeric_uid'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'signature'?: string;
    /**
     *
     * @type {boolean}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'is_verified'?: boolean;
    /**
     *
     * @type {number}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'following'?: number;
    /**
     *
     * @type {number}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'followers'?: number;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
 */
export interface PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray {
    /**
     *
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'signedUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'userAgent'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'browserName'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'browserVersion'?: string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: string; }}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'tokens'?: {
        [key: string]: string;
    };
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: string; }}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'requestHeaders'?: {
        [key: string]: string;
    };
    /**
     *
     * @type {Array<{ [key: string]: string; }>}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'cookies'?: Array<{
        [key: string]: string;
    }>;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
 */
export interface PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString {
    /**
     *
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'status'?: number;
    /**
     *
     * @type {boolean}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'is_live'?: boolean;
    /**
     *
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'cover_url'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'title'?: string;
    /**
     *
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'start_time'?: number;
    /**
     *
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'current_viewers'?: number;
    /**
     *
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'total_viewers'?: number;
    /**
     *
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'hls_pull_url'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'flv_pull_url'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'hls_pull_url_ld'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'flv_pull_url_ld'?: string;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialWebcastRegionRankingsOutputRank
 */
export interface PartialWebcastRegionRankingsOutputRank {
    /**
     *
     * @type {number}
     * @memberof PartialWebcastRegionRankingsOutputRank
     */
    'rank'?: number;
    /**
     *
     * @type {number}
     * @memberof PartialWebcastRegionRankingsOutputRank
     */
    'diamonds'?: number;
    /**
     *
     * @type {string}
     * @memberof PartialWebcastRegionRankingsOutputRank
     */
    'diamonds_description'?: string;
    /**
     *
     * @type {PartialWebcastRegionRankingsOutputRankUser}
     * @memberof PartialWebcastRegionRankingsOutputRank
     */
    'user'?: PartialWebcastRegionRankingsOutputRankUser;
}
/**
 *
 * @export
 * @interface PartialWebcastRegionRankingsOutputRankUser
 */
export interface PartialWebcastRegionRankingsOutputRankUser {
    /**
     *
     * @type {string}
     * @memberof PartialWebcastRegionRankingsOutputRankUser
     */
    'nickname': string;
    /**
     *
     * @type {string}
     * @memberof PartialWebcastRegionRankingsOutputRankUser
     */
    'numeric_id': string;
    /**
     *
     * @type {string}
     * @memberof PartialWebcastRegionRankingsOutputRankUser
     */
    'unique_id': string;
    /**
     *
     * @type {Array<string>}
     * @memberof PartialWebcastRegionRankingsOutputRankUser
     */
    'avatar_thumb': Array<string>;
}
/**
 *
 * @export
 * @interface PeerPresence
 */
export interface PeerPresence {
    /**
     *
     * @type {number}
     * @memberof PeerPresence
     */
    'lastSeen': number;
    /**
     *
     * @type {PeerRole}
     * @memberof PeerPresence
     */
    'role': PeerRole;
    /**
     *
     * @type {string}
     * @memberof PeerPresence
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof PeerPresence
     */
    'type': PeerPresenceTypeEnum;
}
export declare const PeerPresenceTypeEnum: {
    readonly Api: "api";
    readonly Agent: "agent";
};
export type PeerPresenceTypeEnum = typeof PeerPresenceTypeEnum[keyof typeof PeerPresenceTypeEnum];
/**
 *
 * @export
 * @enum {string}
 */
export declare const PeerRole: {
    readonly Public: "public";
    readonly Enterprise: "enterprise";
    readonly Staging: "staging";
};
export type PeerRole = typeof PeerRole[keyof typeof PeerRole];
/**
 * Captcha Server No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  The version of the OpenAPI document: 0.1   NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech). https://openapi-generator.tech Do not edit the class manually.
 * @export
 * @interface Point
 */
export interface Point {
    /**
     *
     * @type {number}
     * @memberof Point
     */
    'x': number;
    /**
     *
     * @type {number}
     * @memberof Point
     */
    'y': number;
}
/**
 *
 * @export
 * @interface PuzzleCaptchaResponse
 */
export interface PuzzleCaptchaResponse {
    /**
     *
     * @type {PuzzleResult}
     * @memberof PuzzleCaptchaResponse
     */
    'response': PuzzleResult | null;
    /**
     *
     * @type {boolean}
     * @memberof PuzzleCaptchaResponse
     */
    'cached': boolean;
    /**
     *
     * @type {number}
     * @memberof PuzzleCaptchaResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof PuzzleCaptchaResponse
     */
    'message'?: string;
}
/**
 * Captcha Server No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  The version of the OpenAPI document: 0.1   NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech). https://openapi-generator.tech Do not edit the class manually.
 * @export
 * @interface PuzzleResult
 */
export interface PuzzleResult {
    /**
     *
     * @type {number}
     * @memberof PuzzleResult
     */
    'time_ms': number;
    /**
     *
     * @type {number}
     * @memberof PuzzleResult
     */
    'x': number;
}
/**
 *
 * @export
 * @interface RateLimitInfo
 */
export interface RateLimitInfo {
    /**
     *
     * @type {number}
     * @memberof RateLimitInfo
     */
    'max': number;
    /**
     *
     * @type {number}
     * @memberof RateLimitInfo
     */
    'remaining': number;
    /**
     *
     * @type {string}
     * @memberof RateLimitInfo
     */
    'reset_at': string | null;
}
/**
 *
 * @export
 * @interface RecordStringBooleanOrNumberValue
 */
export interface RecordStringBooleanOrNumberValue {
}
/**
 *
 * @export
 * @interface RecordStringIsLiveBooleanRoomIdStringOrNullValue
 */
export interface RecordStringIsLiveBooleanRoomIdStringOrNullValue {
    /**
     *
     * @type {string}
     * @memberof RecordStringIsLiveBooleanRoomIdStringOrNullValue
     */
    'room_id': string;
    /**
     *
     * @type {boolean}
     * @memberof RecordStringIsLiveBooleanRoomIdStringOrNullValue
     */
    'is_live': boolean;
}
/**
 *
 * @export
 * @interface RetrieveAccountResponse
 */
export interface RetrieveAccountResponse {
    /**
     *
     * @type {number}
     * @memberof RetrieveAccountResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof RetrieveAccountResponse
     */
    'message'?: string;
    /**
     *
     * @type {AccountWithPermissionsSafe}
     * @memberof RetrieveAccountResponse
     */
    'account'?: AccountWithPermissionsSafe;
}
/**
 *
 * @export
 * @interface RetrieveAgentHostsResponse
 */
export interface RetrieveAgentHostsResponse {
    /**
     *
     * @type {number}
     * @memberof RetrieveAgentHostsResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof RetrieveAgentHostsResponse
     */
    'message'?: string;
    /**
     *
     * @type {Array<PeerPresence>}
     * @memberof RetrieveAgentHostsResponse
     */
    'agents': Array<PeerPresence>;
}
/**
 *
 * @export
 * @interface RetrieveAggregateUsageResponse
 */
export interface RetrieveAggregateUsageResponse {
    /**
     *
     * @type {number}
     * @memberof RetrieveAggregateUsageResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof RetrieveAggregateUsageResponse
     */
    'message'?: string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: { [key: string]: any; }; }}
     * @memberof RetrieveAggregateUsageResponse
     */
    'usage'?: {
        [key: string]: {
            [key: string]: any;
        };
    };
}
/**
 *
 * @export
 * @interface RetrieveAlertResponse
 */
export interface RetrieveAlertResponse {
    /**
     *
     * @type {number}
     * @memberof RetrieveAlertResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof RetrieveAlertResponse
     */
    'message'?: string;
    /**
     *
     * @type {Alert}
     * @memberof RetrieveAlertResponse
     */
    'alert'?: Alert;
    /**
     *
     * @type {RetrieveAlertResponseCreator}
     * @memberof RetrieveAlertResponse
     */
    'creator'?: RetrieveAlertResponseCreator;
}
/**
 *
 * @export
 * @interface RetrieveAlertResponseCreator
 */
export interface RetrieveAlertResponseCreator {
    /**
     *
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'last_nickname': string | null;
    /**
     *
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'last_avatar_url': string | null;
    /**
     *
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'room_id': string | null;
    /**
     *
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'state_label': string;
    /**
     *
     * @type {number}
     * @memberof RetrieveAlertResponseCreator
     */
    'state': number;
    /**
     *
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'unique_id': string;
}
/**
 *
 * @export
 * @interface RetrieveBulkLiveCheckPayload
 */
export interface RetrieveBulkLiveCheckPayload {
    /**
     *
     * @type {Array<string>}
     * @memberof RetrieveBulkLiveCheckPayload
     */
    'user_numeric_ids': Array<string>;
    /**
     *
     * @type {string}
     * @memberof RetrieveBulkLiveCheckPayload
     */
    'session_id': string;
    /**
     *
     * @type {string}
     * @memberof RetrieveBulkLiveCheckPayload
     */
    'tt_target_idc'?: string;
}
/**
 *
 * @export
 * @interface RetrieveBulkLiveCheckResponse
 */
export interface RetrieveBulkLiveCheckResponse {
    /**
     *
     * @type {number}
     * @memberof RetrieveBulkLiveCheckResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof RetrieveBulkLiveCheckResponse
     */
    'message'?: string;
    /**
     *
     * @type {WebcastIsLiveOutput}
     * @memberof RetrieveBulkLiveCheckResponse
     */
    'response'?: WebcastIsLiveOutput;
}
/**
 *
 * @export
 * @interface RetrieveKeyResponse
 */
export interface RetrieveKeyResponse {
    /**
     *
     * @type {number}
     * @memberof RetrieveKeyResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof RetrieveKeyResponse
     */
    'message'?: string;
    /**
     *
     * @type {ApiKey}
     * @memberof RetrieveKeyResponse
     */
    'key'?: ApiKey;
}
/**
 *
 * @export
 * @interface ShapesCaptchaResponse
 */
export interface ShapesCaptchaResponse {
    /**
     *
     * @type {ShapesResult}
     * @memberof ShapesCaptchaResponse
     */
    'response': ShapesResult | null;
    /**
     *
     * @type {boolean}
     * @memberof ShapesCaptchaResponse
     */
    'cached': boolean;
    /**
     *
     * @type {number}
     * @memberof ShapesCaptchaResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof ShapesCaptchaResponse
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface ShapesResult
 */
export interface ShapesResult {
    /**
     *
     * @type {number}
     * @memberof ShapesResult
     */
    'time_ms': number;
    /**
     *
     * @type {Point}
     * @memberof ShapesResult
     */
    'point_1': Point;
    /**
     *
     * @type {Point}
     * @memberof ShapesResult
     */
    'point_2': Point;
}
/**
 *
 * @export
 * @interface SignLogPublic
 */
export interface SignLogPublic {
    /**
     *
     * @type {string}
     * @memberof SignLogPublic
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof SignLogPublic
     */
    'ts': string;
    /**
     *
     * @type {number}
     * @memberof SignLogPublic
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof SignLogPublic
     */
    'client': string;
    /**
     *
     * @type {string}
     * @memberof SignLogPublic
     */
    'ip': string;
    /**
     *
     * @type {number}
     * @memberof SignLogPublic
     */
    'api_key_id': number;
    /**
     *
     * @type {string}
     * @memberof SignLogPublic
     */
    'user_agent': string;
    /**
     *
     * @type {string}
     * @memberof SignLogPublic
     */
    'agent_id': string;
}
/**
 *
 * @export
 * @interface SignTikTokUrlBody
 */
export interface SignTikTokUrlBody {
    /**
     *
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'url': string;
    /**
     *
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'userAgent'?: string;
    /**
     *
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'method'?: SignTikTokUrlBodyMethodEnum;
    /**
     *
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'sessionId'?: string;
    /**
     *
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'ttTargetIdc'?: string;
    /**
     *
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'ttwid'?: string;
    /**
     *
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'payload'?: string;
    /**
     *
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'type'?: SignTikTokUrlBodyTypeEnum;
    /**
     *
     * @type {boolean}
     * @memberof SignTikTokUrlBody
     */
    'includeBrowserParams'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SignTikTokUrlBody
     */
    'includeVerifyFp'?: boolean;
}
export declare const SignTikTokUrlBodyMethodEnum: {
    readonly Get: "GET";
    readonly Post: "POST";
    readonly Options: "OPTIONS";
    readonly Put: "PUT";
    readonly Delete: "DELETE";
    readonly Patch: "PATCH";
    readonly Head: "HEAD";
};
export type SignTikTokUrlBodyMethodEnum = typeof SignTikTokUrlBodyMethodEnum[keyof typeof SignTikTokUrlBodyMethodEnum];
export declare const SignTikTokUrlBodyTypeEnum: {
    readonly Fetch: "fetch";
    readonly Xhr: "xhr";
};
export type SignTikTokUrlBodyTypeEnum = typeof SignTikTokUrlBodyTypeEnum[keyof typeof SignTikTokUrlBodyTypeEnum];
/**
 *
 * @export
 * @interface SignTikTokUrlResponse
 */
export interface SignTikTokUrlResponse {
    /**
     *
     * @type {number}
     * @memberof SignTikTokUrlResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof SignTikTokUrlResponse
     */
    'message'?: string;
    /**
     *
     * @type {PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray}
     * @memberof SignTikTokUrlResponse
     */
    'response'?: PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray;
}
/**
 *
 * @export
 * @interface SignWebcastUrl200Response
 */
export interface SignWebcastUrl200Response {
    /**
     *
     * @type {number}
     * @memberof SignWebcastUrl200Response
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof SignWebcastUrl200Response
     */
    'message'?: string;
    /**
     *
     * @type {PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray}
     * @memberof SignWebcastUrl200Response
     */
    'response'?: PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const SoaxProxyRegion: {
    readonly De: "DE";
    readonly Es: "ES";
    readonly Fr: "FR";
    readonly Gb: "GB";
    readonly Pl: "PL";
};
export type SoaxProxyRegion = typeof SoaxProxyRegion[keyof typeof SoaxProxyRegion];
/**
 *
 * @export
 * @interface SolveResponseIconsResult
 */
export interface SolveResponseIconsResult {
    /**
     *
     * @type {IconsResult}
     * @memberof SolveResponseIconsResult
     */
    'response': IconsResult | null;
    /**
     *
     * @type {boolean}
     * @memberof SolveResponseIconsResult
     */
    'cached': boolean;
    /**
     *
     * @type {number}
     * @memberof SolveResponseIconsResult
     */
    'code': number;
}
/**
 *
 * @export
 * @interface SolveResponsePuzzleResult
 */
export interface SolveResponsePuzzleResult {
    /**
     *
     * @type {PuzzleResult}
     * @memberof SolveResponsePuzzleResult
     */
    'response': PuzzleResult | null;
    /**
     *
     * @type {boolean}
     * @memberof SolveResponsePuzzleResult
     */
    'cached': boolean;
    /**
     *
     * @type {number}
     * @memberof SolveResponsePuzzleResult
     */
    'code': number;
}
/**
 *
 * @export
 * @interface SolveResponseShapesResult
 */
export interface SolveResponseShapesResult {
    /**
     *
     * @type {ShapesResult}
     * @memberof SolveResponseShapesResult
     */
    'response': ShapesResult | null;
    /**
     *
     * @type {boolean}
     * @memberof SolveResponseShapesResult
     */
    'cached': boolean;
    /**
     *
     * @type {number}
     * @memberof SolveResponseShapesResult
     */
    'code': number;
}
/**
 *
 * @export
 * @interface SolveResponseWhirlResult
 */
export interface SolveResponseWhirlResult {
    /**
     *
     * @type {WhirlResult}
     * @memberof SolveResponseWhirlResult
     */
    'response': WhirlResult | null;
    /**
     *
     * @type {boolean}
     * @memberof SolveResponseWhirlResult
     */
    'cached': boolean;
    /**
     *
     * @type {number}
     * @memberof SolveResponseWhirlResult
     */
    'code': number;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const StreamType: {
    readonly HlsLd: "hls_ld";
    readonly HlsSd: "hls_sd";
    readonly FlvLd: "flv_ld";
    readonly FlvSd: "flv_sd";
};
export type StreamType = typeof StreamType[keyof typeof StreamType];
/**
 *
 * @export
 * @interface TestAlertTargetResponse
 */
export interface TestAlertTargetResponse {
    /**
     *
     * @type {number}
     * @memberof TestAlertTargetResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof TestAlertTargetResponse
     */
    'message'?: string;
    /**
     *
     * @type {AlertTargetStatus}
     * @memberof TestAlertTargetResponse
     */
    'status'?: AlertTargetStatus;
    /**
     *
     * @type {string}
     * @memberof TestAlertTargetResponse
     */
    'statusLabel'?: string;
}
/**
 *
 * @export
 * @interface TikTokLiveUser
 */
export interface TikTokLiveUser {
    /**
     *
     * @type {TikTokLiveUserRaw}
     * @memberof TikTokLiveUser
     */
    'raw': TikTokLiveUserRaw;
    /**
     *
     * @type {PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString}
     * @memberof TikTokLiveUser
     */
    'room_info'?: PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString;
    /**
     *
     * @type {TikTokLiveUserUser}
     * @memberof TikTokLiveUser
     */
    'user'?: TikTokLiveUserUser;
    /**
     *
     * @type {string}
     * @memberof TikTokLiveUser
     */
    'unique_id': string;
}
/**
 *
 * @export
 * @interface TikTokLiveUserRaw
 */
export interface TikTokLiveUserRaw {
    /**
     *
     * @type {string}
     * @memberof TikTokLiveUserRaw
     */
    '_note': string;
}
/**
 *
 * @export
 * @interface TikTokLiveUserUser
 */
export interface TikTokLiveUserUser {
    /**
     *
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'avatar_url'?: string;
    /**
     *
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'nickname'?: string;
    /**
     *
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'sec_uid'?: string;
    /**
     *
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'numeric_uid'?: string;
    /**
     *
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'signature'?: string;
    /**
     *
     * @type {boolean}
     * @memberof TikTokLiveUserUser
     */
    'is_verified'?: boolean;
    /**
     *
     * @type {number}
     * @memberof TikTokLiveUserUser
     */
    'following'?: number;
    /**
     *
     * @type {number}
     * @memberof TikTokLiveUserUser
     */
    'followers'?: number;
    /**
     *
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'unique_id': string;
}
/**
 *
 * @export
 * @interface UpdateKeyPayload
 */
export interface UpdateKeyPayload {
    /**
     *
     * @type {string}
     * @memberof UpdateKeyPayload
     */
    'name': string;
}
/**
 *
 * @export
 * @interface UpdateKeyResponse
 */
export interface UpdateKeyResponse {
    /**
     *
     * @type {number}
     * @memberof UpdateKeyResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof UpdateKeyResponse
     */
    'message'?: string;
    /**
     *
     * @type {ApiKey}
     * @memberof UpdateKeyResponse
     */
    'config'?: ApiKey;
}
/**
 *
 * @export
 * @interface WebcastFeedResponse
 */
export interface WebcastFeedResponse {
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponse
     */
    'status_code': number;
    /**
     *
     * @type {WebcastFeedResponseExtra}
     * @memberof WebcastFeedResponse
     */
    'extra': WebcastFeedResponseExtra;
    /**
     *
     * @type {Array<WebcastFeedResponseItem>}
     * @memberof WebcastFeedResponse
     */
    'data': Array<WebcastFeedResponseItem>;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseExtra
 */
export interface WebcastFeedResponseExtra {
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseExtra
     */
    'now': number;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseExtra
     */
    'unread_extra': string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastFeedResponseExtra
     */
    'banner': {
        [key: string]: any;
    };
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseExtra
     */
    'total': number;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseExtra
     */
    'max_time': number;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseExtra
     */
    'cost': number;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseExtra
     */
    'is_backup': number;
    /**
     *
     * @type {boolean}
     * @memberof WebcastFeedResponseExtra
     */
    'has_more': boolean;
    /**
     *
     * @type {WebcastFeedResponseExtraLogPb}
     * @memberof WebcastFeedResponseExtra
     */
    'log_pb': WebcastFeedResponseExtraLogPb;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseExtraLogPb
 */
export interface WebcastFeedResponseExtraLogPb {
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseExtraLogPb
     */
    'impr_id': string;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseHashtag
 */
export interface WebcastFeedResponseHashtag {
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseHashtag
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseHashtag
     */
    'title': string;
    /**
     *
     * @type {WebcastFeedResponseRoomDataFeedRoomLabel}
     * @memberof WebcastFeedResponseHashtag
     */
    'image': WebcastFeedResponseRoomDataFeedRoomLabel;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseImage
 */
export interface WebcastFeedResponseImage {
    /**
     *
     * @type {Array<string>}
     * @memberof WebcastFeedResponseImage
     */
    'url_list': Array<string>;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseImage
     */
    'uri': string;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseItem
 */
export interface WebcastFeedResponseItem {
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseItem
     */
    'type': number;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseItem
     */
    'rid': string;
    /**
     *
     * @type {WebcastFeedResponseRoomData}
     * @memberof WebcastFeedResponseItem
     */
    'data': WebcastFeedResponseRoomData;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastFeedResponseItem
     */
    'flare_info': {
        [key: string]: any;
    };
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseItem
     */
    'room_event_tracking': string;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseRoomData
 */
export interface WebcastFeedResponseRoomData {
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseRoomData
     */
    'id_str': string;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'status': number;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'owner_user_id': number;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseRoomData
     */
    'title': string;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'user_count': number;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'client_version': number;
    /**
     *
     * @type {WebcastFeedResponseImage}
     * @memberof WebcastFeedResponseRoomData
     */
    'cover': WebcastFeedResponseImage;
    /**
     *
     * @type {WebcastFeedResponseStreamUrl}
     * @memberof WebcastFeedResponseRoomData
     */
    'stream_url': WebcastFeedResponseStreamUrl;
    /**
     *
     * @type {WebcastFeedResponseRoomDataStats}
     * @memberof WebcastFeedResponseRoomData
     */
    'stats': WebcastFeedResponseRoomDataStats;
    /**
     *
     * @type {WebcastFeedResponseRoomDataFeedRoomLabel}
     * @memberof WebcastFeedResponseRoomData
     */
    'feed_room_label': WebcastFeedResponseRoomDataFeedRoomLabel;
    /**
     *
     * @type {WebcastFeedResponseUser}
     * @memberof WebcastFeedResponseRoomData
     */
    'owner': WebcastFeedResponseUser;
    /**
     *
     * @type {boolean}
     * @memberof WebcastFeedResponseRoomData
     */
    'live_type_third_party': boolean;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: RecordStringBooleanOrNumberValue; }}
     * @memberof WebcastFeedResponseRoomData
     */
    'room_auth': {
        [key: string]: RecordStringBooleanOrNumberValue;
    };
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'like_count': number;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'anchor_tab_type': number;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastFeedResponseRoomData
     */
    'commerce_info': {
        [key: string]: any;
    };
    /**
     *
     * @type {WebcastFeedResponseHashtag}
     * @memberof WebcastFeedResponseRoomData
     */
    'hashtag'?: WebcastFeedResponseHashtag;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'live_room_mode': number;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastFeedResponseRoomData
     */
    'stream_url_filtered_info': {
        [key: string]: any;
    };
    /**
     *
     * @type {WebcastFeedResponseRoomDataSquareCoverImg}
     * @memberof WebcastFeedResponseRoomData
     */
    'square_cover_img': WebcastFeedResponseRoomDataSquareCoverImg;
    /**
     *
     * @type {WebcastFeedResponseRoomDataFeedRoomLabel}
     * @memberof WebcastFeedResponseRoomData
     */
    'rectangle_cover_img': WebcastFeedResponseRoomDataFeedRoomLabel;
    /**
     *
     * @type {WebcastFeedResponseRoomDataSquareCoverImg}
     * @memberof WebcastFeedResponseRoomData
     */
    'blurred_cover': WebcastFeedResponseRoomDataSquareCoverImg;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastFeedResponseRoomData
     */
    'multi_stream_url': {
        [key: string]: any;
    };
    /**
     *
     * @type {WebcastFeedResponseRoomDataGameTagDetail}
     * @memberof WebcastFeedResponseRoomData
     */
    'game_tag_detail': WebcastFeedResponseRoomDataGameTagDetail;
    /**
     *
     * @type {WebcastFeedResponseRoomDataTaxonomyTagInfo}
     * @memberof WebcastFeedResponseRoomData
     */
    'taxonomy_tag_info': WebcastFeedResponseRoomDataTaxonomyTagInfo;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseRoomDataFeedRoomLabel
 */
export interface WebcastFeedResponseRoomDataFeedRoomLabel {
    /**
     *
     * @type {Array<string>}
     * @memberof WebcastFeedResponseRoomDataFeedRoomLabel
     */
    'url_list': Array<string>;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataFeedRoomLabel
     */
    'uri': string;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataFeedRoomLabel
     */
    'avg_color': string;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseRoomDataGameTagDetail
 */
export interface WebcastFeedResponseRoomDataGameTagDetail {
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataGameTagDetail
     */
    'display_name': string;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataGameTagDetail
     */
    'starling_key': string;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataGameTagDetail
     */
    'game_tag_name': string;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseRoomDataGameTagDetail
     */
    'game_tag_id': number;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseRoomDataSquareCoverImg
 */
export interface WebcastFeedResponseRoomDataSquareCoverImg {
    /**
     *
     * @type {Array<string>}
     * @memberof WebcastFeedResponseRoomDataSquareCoverImg
     */
    'url_list': Array<string>;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataSquareCoverImg
     */
    'uri': string;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataSquareCoverImg
     */
    'avg_color': string;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseRoomDataSquareCoverImg
     */
    'width': number;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseRoomDataSquareCoverImg
     */
    'height': number;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseRoomDataStats
 */
export interface WebcastFeedResponseRoomDataStats {
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseRoomDataStats
     */
    'comment_count': number;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseRoomDataStats
     */
    'enter_count': number;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseRoomDataStats
     */
    'total_user': number;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseRoomDataTaxonomyTagInfo
 */
export interface WebcastFeedResponseRoomDataTaxonomyTagInfo {
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataTaxonomyTagInfo
     */
    'level2_tag': string;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseStreamUrl
 */
export interface WebcastFeedResponseStreamUrl {
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseStreamUrl
     */
    'rtmp_pull_url': string;
    /**
     *
     * @type {WebcastFeedResponseStreamUrlFlvPullUrl}
     * @memberof WebcastFeedResponseStreamUrl
     */
    'flv_pull_url': WebcastFeedResponseStreamUrlFlvPullUrl;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: string; }}
     * @memberof WebcastFeedResponseStreamUrl
     */
    'flv_pull_url_params'?: {
        [key: string]: string;
    };
    /**
     *
     * @type {WebcastFeedResponseStreamUrlLiveCoreSdkData}
     * @memberof WebcastFeedResponseStreamUrl
     */
    'live_core_sdk_data'?: WebcastFeedResponseStreamUrlLiveCoreSdkData;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseStreamUrl
     */
    'stream_size_width': number;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseStreamUrl
     */
    'stream_size_height': number;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseStreamUrlFlvPullUrl
 */
export interface WebcastFeedResponseStreamUrlFlvPullUrl {
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseStreamUrlFlvPullUrl
     */
    'SD1'?: string;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseStreamUrlFlvPullUrl
     */
    'SD2'?: string;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseStreamUrlFlvPullUrl
     */
    'HD1'?: string;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseStreamUrlLiveCoreSdkData
 */
export interface WebcastFeedResponseStreamUrlLiveCoreSdkData {
    /**
     *
     * @type {WebcastFeedResponseStreamUrlLiveCoreSdkDataPullData}
     * @memberof WebcastFeedResponseStreamUrlLiveCoreSdkData
     */
    'pull_data': WebcastFeedResponseStreamUrlLiveCoreSdkDataPullData;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseStreamUrlLiveCoreSdkDataPullData
 */
export interface WebcastFeedResponseStreamUrlLiveCoreSdkDataPullData {
    /**
     *
     * @type {WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptions}
     * @memberof WebcastFeedResponseStreamUrlLiveCoreSdkDataPullData
     */
    'options': WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptions;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseStreamUrlLiveCoreSdkDataPullData
     */
    'stream_data': string;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptions
 */
export interface WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptions {
    /**
     *
     * @type {WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptionsDefaultQuality}
     * @memberof WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptions
     */
    'default_quality': WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptionsDefaultQuality;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptionsDefaultQuality
 */
export interface WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptionsDefaultQuality {
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptionsDefaultQuality
     */
    'sdk_key': string;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptionsDefaultQuality
     */
    'name': string;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseUser
 */
export interface WebcastFeedResponseUser {
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseUser
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseUser
     */
    'nickname': string;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseUser
     */
    'bio_description': string;
    /**
     *
     * @type {WebcastFeedResponseImage}
     * @memberof WebcastFeedResponseUser
     */
    'avatar_thumb': WebcastFeedResponseImage;
    /**
     *
     * @type {WebcastFeedResponseImage}
     * @memberof WebcastFeedResponseUser
     */
    'avatar_medium': WebcastFeedResponseImage;
    /**
     *
     * @type {WebcastFeedResponseImage}
     * @memberof WebcastFeedResponseUser
     */
    'avatar_large': WebcastFeedResponseImage;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseUser
     */
    'status': number;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseUser
     */
    'modify_time': number;
    /**
     *
     * @type {WebcastFeedResponseUserFollowInfo}
     * @memberof WebcastFeedResponseUser
     */
    'follow_info': WebcastFeedResponseUserFollowInfo;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastFeedResponseUser
     */
    'pay_grade': {
        [key: string]: any;
    };
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastFeedResponseUser
     */
    'user_attr': {
        [key: string]: any;
    };
    /**
     *
     * @type {WebcastFeedResponseUserOwnRoom}
     * @memberof WebcastFeedResponseUser
     */
    'own_room': WebcastFeedResponseUserOwnRoom;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseUser
     */
    'display_id': string;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseUser
     */
    'sec_uid': string;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedResponseUser
     */
    'id_str': string;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseUserFollowInfo
 */
export interface WebcastFeedResponseUserFollowInfo {
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseUserFollowInfo
     */
    'follower_count': number;
    /**
     *
     * @type {number}
     * @memberof WebcastFeedResponseUserFollowInfo
     */
    'following_count': number;
}
/**
 *
 * @export
 * @interface WebcastFeedResponseUserOwnRoom
 */
export interface WebcastFeedResponseUserOwnRoom {
    /**
     *
     * @type {Array<string>}
     * @memberof WebcastFeedResponseUserOwnRoom
     */
    'room_ids_str': Array<string>;
    /**
     *
     * @type {Array<number>}
     * @memberof WebcastFeedResponseUserOwnRoom
     */
    'room_ids': Array<number>;
}
/**
 *
 * @export
 * @interface WebcastFeedRouteOutput
 */
export interface WebcastFeedRouteOutput {
    /**
     *
     * @type {WebcastFeedResponse}
     * @memberof WebcastFeedRouteOutput
     */
    'data': WebcastFeedResponse;
}
/**
 *
 * @export
 * @interface WebcastFeedRouteResponse
 */
export interface WebcastFeedRouteResponse {
    /**
     *
     * @type {number}
     * @memberof WebcastFeedRouteResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof WebcastFeedRouteResponse
     */
    'message'?: string;
    /**
     *
     * @type {WebcastFeedRouteOutput}
     * @memberof WebcastFeedRouteResponse
     */
    'response'?: WebcastFeedRouteOutput;
    /**
     *
     * @type {OxyLabsProxyRegion}
     * @memberof WebcastFeedRouteResponse
     */
    'region': OxyLabsProxyRegion;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const WebcastFetchPlatform: {
    readonly Mobile: "mobile";
    readonly Web: "web";
};
export type WebcastFetchPlatform = typeof WebcastFetchPlatform[keyof typeof WebcastFetchPlatform];
/**
 *
 * @export
 * @interface WebcastGiftInfoOutput
 */
export interface WebcastGiftInfoOutput {
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastGiftInfoOutput
     */
    'data': {
        [key: string]: any;
    };
}
/**
 *
 * @export
 * @interface WebcastGiftInfoRouteResponse
 */
export interface WebcastGiftInfoRouteResponse {
    /**
     *
     * @type {number}
     * @memberof WebcastGiftInfoRouteResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof WebcastGiftInfoRouteResponse
     */
    'message'?: string;
    /**
     *
     * @type {WebcastGiftInfoOutput}
     * @memberof WebcastGiftInfoRouteResponse
     */
    'response'?: WebcastGiftInfoOutput;
}
/**
 *
 * @export
 * @interface WebcastIsLiveOutput
 */
export interface WebcastIsLiveOutput {
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: RecordStringIsLiveBooleanRoomIdStringOrNullValue; }}
     * @memberof WebcastIsLiveOutput
     */
    'data'?: {
        [key: string]: RecordStringIsLiveBooleanRoomIdStringOrNullValue;
    };
}
/**
 *
 * @export
 * @interface WebcastRegionRankingsOutput
 */
export interface WebcastRegionRankingsOutput {
    /**
     *
     * @type {Array<PartialWebcastRegionRankingsOutputRank>}
     * @memberof WebcastRegionRankingsOutput
     */
    'ranks': Array<PartialWebcastRegionRankingsOutputRank>;
    /**
     *
     * @type {string}
     * @memberof WebcastRegionRankingsOutput
     */
    'rank_title': string | null;
    /**
     *
     * @type {string}
     * @memberof WebcastRegionRankingsOutput
     */
    'rank_type': string | null;
    /**
     *
     * @type {string}
     * @memberof WebcastRegionRankingsOutput
     */
    'resets_at': string | null;
    /**
     *
     * @type {number}
     * @memberof WebcastRegionRankingsOutput
     */
    'resets_in': number | null;
}
/**
 *
 * @export
 * @interface WebcastRegionRankingsResponse
 */
export interface WebcastRegionRankingsResponse {
    /**
     *
     * @type {number}
     * @memberof WebcastRegionRankingsResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof WebcastRegionRankingsResponse
     */
    'message'?: string;
    /**
     *
     * @type {WebcastRegionRankingsOutput}
     * @memberof WebcastRegionRankingsResponse
     */
    'response'?: WebcastRegionRankingsOutput;
    /**
     *
     * @type {OxyLabsProxyRegion}
     * @memberof WebcastRegionRankingsResponse
     */
    'region': OxyLabsProxyRegion;
}
/**
 *
 * @export
 * @interface WebcastRoomChatPayload
 */
export interface WebcastRoomChatPayload {
    /**
     *
     * @type {string}
     * @memberof WebcastRoomChatPayload
     */
    'content': string;
    /**
     *
     * @type {string}
     * @memberof WebcastRoomChatPayload
     */
    'sessionId': string;
    /**
     *
     * @type {string}
     * @memberof WebcastRoomChatPayload
     */
    'ttTargetIdc': string;
    /**
     *
     * @type {string}
     * @memberof WebcastRoomChatPayload
     */
    'roomId': string;
}
/**
 *
 * @export
 * @interface WebcastRoomChatRouteResponse
 */
export interface WebcastRoomChatRouteResponse {
    /**
     *
     * @type {number}
     * @memberof WebcastRoomChatRouteResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof WebcastRoomChatRouteResponse
     */
    'message'?: string;
    /**
     *
     * @type {any}
     * @memberof WebcastRoomChatRouteResponse
     */
    'data'?: any;
}
/**
 *
 * @export
 * @interface WebcastRoomIdRouteResponse
 */
export interface WebcastRoomIdRouteResponse {
    /**
     *
     * @type {number}
     * @memberof WebcastRoomIdRouteResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof WebcastRoomIdRouteResponse
     */
    'message'?: string;
    /**
     *
     * @type {boolean}
     * @memberof WebcastRoomIdRouteResponse
     */
    'ok': boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof WebcastRoomIdRouteResponse
     */
    'routes_attempted': Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof WebcastRoomIdRouteResponse
     */
    'is_live'?: boolean;
    /**
     *
     * @type {string}
     * @memberof WebcastRoomIdRouteResponse
     */
    'room_id'?: string;
}
/**
 *
 * @export
 * @interface WebcastRoomInfoRouteResponse
 */
export interface WebcastRoomInfoRouteResponse {
    /**
     *
     * @type {number}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'message'?: string;
    /**
     *
     * @type {boolean}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'ok': boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'routes_attempted': Array<string>;
    /**
     *
     * @type {TikTokLiveUser}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'data': TikTokLiveUser | null;
}
/**
 *
 * @export
 * @interface WebcastUserEarningsOutput
 */
export interface WebcastUserEarningsOutput {
    /**
     *
     * @type {TikTokLiveUser}
     * @memberof WebcastUserEarningsOutput
     */
    'user': TikTokLiveUser;
    /**
     *
     * @type {string}
     * @memberof WebcastUserEarningsOutput
     */
    'earnings_estimate_currency': WebcastUserEarningsOutputEarningsEstimateCurrencyEnum | null;
    /**
     *
     * @type {number}
     * @memberof WebcastUserEarningsOutput
     */
    'earnings_estimate': number | null;
    /**
     *
     * @type {number}
     * @memberof WebcastUserEarningsOutput
     */
    'diamonds': number | null;
    /**
     *
     * @type {WebcastUserEarningsOutputPeriod}
     * @memberof WebcastUserEarningsOutput
     */
    'period': WebcastUserEarningsOutputPeriod;
    /**
     *
     * @type {string}
     * @memberof WebcastUserEarningsOutput
     */
    'resets_at': string | null;
    /**
     *
     * @type {number}
     * @memberof WebcastUserEarningsOutput
     */
    'resets_in': number | null;
}
export declare const WebcastUserEarningsOutputEarningsEstimateCurrencyEnum: {
    readonly Usd: "USD";
};
export type WebcastUserEarningsOutputEarningsEstimateCurrencyEnum = typeof WebcastUserEarningsOutputEarningsEstimateCurrencyEnum[keyof typeof WebcastUserEarningsOutputEarningsEstimateCurrencyEnum];
/**
 *
 * @export
 * @enum {string}
 */
export declare const WebcastUserEarningsOutputPeriod: {
    readonly Daily: "daily";
};
export type WebcastUserEarningsOutputPeriod = typeof WebcastUserEarningsOutputPeriod[keyof typeof WebcastUserEarningsOutputPeriod];
/**
 *
 * @export
 * @interface WebcastUserEarningsResponse
 */
export interface WebcastUserEarningsResponse {
    /**
     *
     * @type {number}
     * @memberof WebcastUserEarningsResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof WebcastUserEarningsResponse
     */
    'message'?: string;
    /**
     *
     * @type {WebcastUserEarningsOutput}
     * @memberof WebcastUserEarningsResponse
     */
    'response'?: WebcastUserEarningsOutput;
}
/**
 *
 * @export
 * @interface WhirlCaptchaResponse
 */
export interface WhirlCaptchaResponse {
    /**
     *
     * @type {WhirlResult}
     * @memberof WhirlCaptchaResponse
     */
    'response': WhirlResult | null;
    /**
     *
     * @type {boolean}
     * @memberof WhirlCaptchaResponse
     */
    'cached': boolean;
    /**
     *
     * @type {number}
     * @memberof WhirlCaptchaResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof WhirlCaptchaResponse
     */
    'message'?: string;
}
/**
 * Captcha Server No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  The version of the OpenAPI document: 0.1   NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech). https://openapi-generator.tech Do not edit the class manually.
 * @export
 * @interface WhirlResult
 */
export interface WhirlResult {
    /**
     *
     * @type {number}
     * @memberof WhirlResult
     */
    'time_ms': number;
    /**
     *
     * @type {number}
     * @memberof WhirlResult
     */
    'angle': number;
}
/**
 * AccountsApi - axios parameter creator
 * @export
 */
export declare const AccountsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countSignUsage: (accountId: number, from: string, to: string, apiKeyId?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {number} [page] Page number to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignUsage: (accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve an account from the Sign API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAccountSelf: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
     * @param {number} value The value for the period (either hours or numbers)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAggregateUsage: (accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AccountsApi - functional programming interface
 * @export
 */
export declare const AccountsApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountSignUsage>>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {number} [page] Page number to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignUsageResponse>>;
    /**
     * Retrieve an account from the Sign API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAccountSelf(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveAccountResponse>>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
     * @param {number} value The value for the period (either hours or numbers)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAggregateUsage(accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveAggregateUsageResponse>>;
};
/**
 * AccountsApi - factory interface
 * @export
 */
export declare const AccountsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, options?: RawAxiosRequestConfig): AxiosPromise<CountSignUsage>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {number} [page] Page number to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetSignUsageResponse>;
    /**
     * Retrieve an account from the Sign API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAccountSelf(options?: RawAxiosRequestConfig): AxiosPromise<RetrieveAccountResponse>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
     * @param {number} value The value for the period (either hours or numbers)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAggregateUsage(accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options?: RawAxiosRequestConfig): AxiosPromise<RetrieveAggregateUsageResponse>;
};
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export declare class AccountsApi extends BaseAPI {
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    countSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<CountSignUsage, any>>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {number} [page] Page number to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<GetSignUsageResponse, any>>;
    /**
     * Retrieve an account from the Sign API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    retrieveAccountSelf(options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<RetrieveAccountResponse, any>>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
     * @param {number} value The value for the period (either hours or numbers)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    retrieveAggregateUsage(accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<RetrieveAggregateUsageResponse, any>>;
}
/**
 * @export
 */
export declare const RetrieveAggregateUsagePeriodEnum: {
    readonly Hour: "hour";
    readonly Day: "day";
};
export type RetrieveAggregateUsagePeriodEnum = typeof RetrieveAggregateUsagePeriodEnum[keyof typeof RetrieveAggregateUsagePeriodEnum];
/**
 * AlertTargetsApi - axios parameter creator
 * @export
 */
export declare const AlertTargetsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
     * @param {number} accountId The ID of the account to create the alert target for
     * @param {number} alertId The ID of the alert to create the target for
     * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlertTarget: (accountId: number, alertId: number, createAlertTargetPayload: CreateAlertTargetPayload, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete an alert target from the Sign API
     * @param {number} accountId The ID of the account to delete the alert target from
     * @param {number} alertId The ID of the alert to delete the target from
     * @param {number} targetId The ID of the target to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlertTarget: (accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List all alert targets for a specific alert
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert to list targets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAlertTargets: (accountId: number, alertId: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Test an alert target
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert that the target belongs to
     * @param {number} targetId The target to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testAlertTarget: (accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AlertTargetsApi - functional programming interface
 * @export
 */
export declare const AlertTargetsApiFp: (configuration?: Configuration) => {
    /**
     * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
     * @param {number} accountId The ID of the account to create the alert target for
     * @param {number} alertId The ID of the alert to create the target for
     * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlertTarget(accountId: number, alertId: number, createAlertTargetPayload: CreateAlertTargetPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAlertTargetResponse>>;
    /**
     * Delete an alert target from the Sign API
     * @param {number} accountId The ID of the account to delete the alert target from
     * @param {number} alertId The ID of the alert to delete the target from
     * @param {number} targetId The ID of the target to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAlertTargetResponse>>;
    /**
     * List all alert targets for a specific alert
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert to list targets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAlertTargetsResponse>>;
    /**
     * Test an alert target
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert that the target belongs to
     * @param {number} targetId The target to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestAlertTargetResponse>>;
};
/**
 * AlertTargetsApi - factory interface
 * @export
 */
export declare const AlertTargetsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
     * @param {number} accountId The ID of the account to create the alert target for
     * @param {number} alertId The ID of the alert to create the target for
     * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlertTarget(accountId: number, alertId: number, createAlertTargetPayload: CreateAlertTargetPayload, options?: RawAxiosRequestConfig): AxiosPromise<CreateAlertTargetResponse>;
    /**
     * Delete an alert target from the Sign API
     * @param {number} accountId The ID of the account to delete the alert target from
     * @param {number} alertId The ID of the alert to delete the target from
     * @param {number} targetId The ID of the target to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAlertTargetResponse>;
    /**
     * List all alert targets for a specific alert
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert to list targets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListAlertTargetsResponse>;
    /**
     * Test an alert target
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert that the target belongs to
     * @param {number} targetId The target to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): AxiosPromise<TestAlertTargetResponse>;
};
/**
 * AlertTargetsApi - object-oriented interface
 * @export
 * @class AlertTargetsApi
 * @extends {BaseAPI}
 */
export declare class AlertTargetsApi extends BaseAPI {
    /**
     * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
     * @param {number} accountId The ID of the account to create the alert target for
     * @param {number} alertId The ID of the alert to create the target for
     * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    createAlertTarget(accountId: number, alertId: number, createAlertTargetPayload: CreateAlertTargetPayload, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<CreateAlertTargetResponse, any>>;
    /**
     * Delete an alert target from the Sign API
     * @param {number} accountId The ID of the account to delete the alert target from
     * @param {number} alertId The ID of the alert to delete the target from
     * @param {number} targetId The ID of the target to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<DeleteAlertTargetResponse, any>>;
    /**
     * List all alert targets for a specific alert
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert to list targets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<ListAlertTargetsResponse, any>>;
    /**
     * Test an alert target
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert that the target belongs to
     * @param {number} targetId The target to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<TestAlertTargetResponse, any>>;
}
/**
 * AlertsApi - axios parameter creator
 * @export
 */
export declare const AlertsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a creator alert. These Alerts are used to notify users of a new livestream.
     * @param {number} accountId The ID of the account to create the alert for
     * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlert: (accountId: number, createAlertRequest: CreateAlertRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete an alert from the Sign API
     * @param {number} accountId The ID of the account to delete the alert from
     * @param {number} alertId The ID of the alert to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlert: (accountId: number, alertId: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @param {number} accountId
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAlerts: (accountId: number, page?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve a specific alert by its ID
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The ID of the alert to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAlert: (accountId: number, alertId: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AlertsApi - functional programming interface
 * @export
 */
export declare const AlertsApiFp: (configuration?: Configuration) => {
    /**
     * Create a creator alert. These Alerts are used to notify users of a new livestream.
     * @param {number} accountId The ID of the account to create the alert for
     * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlert(accountId: number, createAlertRequest: CreateAlertRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAlertResponse>>;
    /**
     * Delete an alert from the Sign API
     * @param {number} accountId The ID of the account to delete the alert from
     * @param {number} alertId The ID of the alert to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAlertResponse>>;
    /**
     *
     * @param {number} accountId
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAlerts(accountId: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAlertsResponse>>;
    /**
     * Retrieve a specific alert by its ID
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The ID of the alert to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveAlertResponse>>;
};
/**
 * AlertsApi - factory interface
 * @export
 */
export declare const AlertsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a creator alert. These Alerts are used to notify users of a new livestream.
     * @param {number} accountId The ID of the account to create the alert for
     * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlert(accountId: number, createAlertRequest: CreateAlertRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAlertResponse>;
    /**
     * Delete an alert from the Sign API
     * @param {number} accountId The ID of the account to delete the alert from
     * @param {number} alertId The ID of the alert to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAlertResponse>;
    /**
     *
     * @param {number} accountId
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAlerts(accountId: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListAlertsResponse>;
    /**
     * Retrieve a specific alert by its ID
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The ID of the alert to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<RetrieveAlertResponse>;
};
/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export declare class AlertsApi extends BaseAPI {
    /**
     * Create a creator alert. These Alerts are used to notify users of a new livestream.
     * @param {number} accountId The ID of the account to create the alert for
     * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    createAlert(accountId: number, createAlertRequest: CreateAlertRequest, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<CreateAlertResponse, any>>;
    /**
     * Delete an alert from the Sign API
     * @param {number} accountId The ID of the account to delete the alert from
     * @param {number} alertId The ID of the alert to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    deleteAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<DeleteAlertResponse, any>>;
    /**
     *
     * @param {number} accountId
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    listAlerts(accountId: number, page?: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<ListAlertsResponse, any>>;
    /**
     * Retrieve a specific alert by its ID
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The ID of the alert to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    retrieveAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<RetrieveAlertResponse, any>>;
}
/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export declare const AnalyticsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve the currently connected agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAgents: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the list of API hosts (used for horizontal scaling)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHosts: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export declare const AnalyticsApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve the currently connected agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAgents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveAgentHostsResponse>>;
    /**
     * Retrieve the list of API hosts (used for horizontal scaling)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHosts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostsResponse>>;
};
/**
 * AnalyticsApi - factory interface
 * @export
 */
export declare const AnalyticsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieve the currently connected agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAgents(options?: RawAxiosRequestConfig): AxiosPromise<RetrieveAgentHostsResponse>;
    /**
     * Retrieve the list of API hosts (used for horizontal scaling)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHosts(options?: RawAxiosRequestConfig): AxiosPromise<HostsResponse>;
};
/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export declare class AnalyticsApi extends BaseAPI {
    /**
     * Retrieve the currently connected agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    fetchAgents(options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<RetrieveAgentHostsResponse, any>>;
    /**
     * Retrieve the list of API hosts (used for horizontal scaling)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getHosts(options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<HostsResponse, any>>;
}
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export declare const AuthenticationApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
     * @param {number} accountId The ID of the account to create the JWT for
     * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJWT: (accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new API key
     * @param {number} accountId The ID of the account to create the key for
     * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createKey: (accountId: number, createKeyPayload: CreateKeyPayload, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to delete the key for
     * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
     * @param {string} deleteParam The API key field value to delete by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteKey: (accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {string} retrieveParam The API key field value to retrieve by
     * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKey: (accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listKeys: (accountId: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update an existing API key
     * @param {number} accountId The account to update the key for
     * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
     * @param {string} updateParam The API key field value to update by
     * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateKey: (accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, updateKeyPayload: UpdateKeyPayload, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export declare const AuthenticationApiFp: (configuration?: Configuration) => {
    /**
     * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
     * @param {number} accountId The ID of the account to create the JWT for
     * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateJWTResponse>>;
    /**
     * Create a new API key
     * @param {number} accountId The ID of the account to create the key for
     * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createKey(accountId: number, createKeyPayload: CreateKeyPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateKeyResponse>>;
    /**
     * Delete an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to delete the key for
     * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
     * @param {string} deleteParam The API key field value to delete by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteKeyResponse>>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {string} retrieveParam The API key field value to retrieve by
     * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveKeyResponse>>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listKeys(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListKeysResponse>>;
    /**
     * Update an existing API key
     * @param {number} accountId The account to update the key for
     * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
     * @param {string} updateParam The API key field value to update by
     * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, updateKeyPayload: UpdateKeyPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateKeyResponse>>;
};
/**
 * AuthenticationApi - factory interface
 * @export
 */
export declare const AuthenticationApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
     * @param {number} accountId The ID of the account to create the JWT for
     * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig): AxiosPromise<CreateJWTResponse>;
    /**
     * Create a new API key
     * @param {number} accountId The ID of the account to create the key for
     * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createKey(accountId: number, createKeyPayload: CreateKeyPayload, options?: RawAxiosRequestConfig): AxiosPromise<CreateKeyResponse>;
    /**
     * Delete an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to delete the key for
     * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
     * @param {string} deleteParam The API key field value to delete by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteKeyResponse>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {string} retrieveParam The API key field value to retrieve by
     * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig): AxiosPromise<RetrieveKeyResponse>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listKeys(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListKeysResponse>;
    /**
     * Update an existing API key
     * @param {number} accountId The account to update the key for
     * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
     * @param {string} updateParam The API key field value to update by
     * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, updateKeyPayload: UpdateKeyPayload, options?: RawAxiosRequestConfig): AxiosPromise<UpdateKeyResponse>;
};
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export declare class AuthenticationApi extends BaseAPI {
    /**
     * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
     * @param {number} accountId The ID of the account to create the JWT for
     * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<CreateJWTResponse, any>>;
    /**
     * Create a new API key
     * @param {number} accountId The ID of the account to create the key for
     * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    createKey(accountId: number, createKeyPayload: CreateKeyPayload, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<CreateKeyResponse, any>>;
    /**
     * Delete an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to delete the key for
     * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
     * @param {string} deleteParam The API key field value to delete by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<DeleteKeyResponse, any>>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {string} retrieveParam The API key field value to retrieve by
     * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<RetrieveKeyResponse, any>>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    listKeys(accountId: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<ListKeysResponse, any>>;
    /**
     * Update an existing API key
     * @param {number} accountId The account to update the key for
     * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
     * @param {string} updateParam The API key field value to update by
     * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, updateKeyPayload: UpdateKeyPayload, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<UpdateKeyResponse, any>>;
}
/**
 * @export
 */
export declare const DeleteKeyDeleteByEnum: {
    readonly Value: "value";
    readonly Id: "id";
};
export type DeleteKeyDeleteByEnum = typeof DeleteKeyDeleteByEnum[keyof typeof DeleteKeyDeleteByEnum];
/**
 * @export
 */
export declare const GetKeyRetrieveByEnum: {
    readonly Value: "value";
    readonly Id: "id";
};
export type GetKeyRetrieveByEnum = typeof GetKeyRetrieveByEnum[keyof typeof GetKeyRetrieveByEnum];
/**
 * @export
 */
export declare const UpdateKeyUpdateByEnum: {
    readonly Value: "value";
    readonly Id: "id";
};
export type UpdateKeyUpdateByEnum = typeof UpdateKeyUpdateByEnum[keyof typeof UpdateKeyUpdateByEnum];
/**
 * CaptchasApi - axios parameter creator
 * @export
 */
export declare const CaptchasApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * ## âš ï¸ Warning: Requires Business plan or higher  The icons captcha requires just one image & a prompt string.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/icon.png\" alt=\"Icons Captcha Example\" width=\"480\" />  ## Usage  The `prompt` is the text prompt provided by TikTok. The Icon captcha solution is provided as a list of points, where each point marks a location on the image that needs to be clicked. These points are expressed as ratios relative to the image\'s width and height. A point of (0.0, 0.0) corresponds to the imageâ€™s upper-left corner, while (1.0, 1.0) represents the lower-right corner. For reference, (0.5, 0.5) sits at the exact center.  The captcha image selector is `.captcha-verify-image`
     * @param {string} prompt The prompt string provided by TikTok
     * @param {File} captchaImage The uploaded image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeIconCaptcha: (prompt: string, captchaImage: File, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * The puzzle captcha requires two images  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/puzzle.png\" alt=\"Puzzle Piece Example\" width=\"480\" />  ## Usage  The solution to the puzzle captcha is the distance to move the slider to fit the puzzle piece into the background.  The `backgroundImage` is the full background image with the missing piece. The `pieceImage` is the small puzzle piece that needs to be fit into the background.  The captcha image selectors are: - Background: `.captcha-verify-image` - Piece: `#captcha-verify-image ~ div.cap-absolute > img`  The solution is the `x` proportion (0-1) of the width of the background image where the piece fits. It is 1:1 with the slider distance proportion.
     * @param {File} backgroundImage The uploaded background image file
     * @param {File} pieceImage The uploaded puzzle piece image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completePuzzleCaptcha: (backgroundImage: File, pieceImage: File, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * The shapes captcha requires just one image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/threed.png\" alt=\"Shapes Captcha Example\" width=\"480\" />  ## Usage  The solution to the shapes captcha are two points that need to be clicked. To use it in the GUI, convert the proportions to pixel values based on the image size.  The `points` are returned as `x` and `y` proportions (0-1) of the width and height of the source image. The captcha image selector is `.captcha-verify-image`
     * @param {File} shapesCaptchaImage The uploaded image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeShapesCaptcha: (shapesCaptchaImage: File, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * The whirl captcha requires two images: the outer image and the inner image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/rotate.png\" alt=\"Whirl Captcha Example\" width=\"480\" />  ## Usage  The solution to the whirl captcha is an angle from 0-360. To use it in the GUI, it must be converted to a slider distance:  `px = ((sidebar_length - icon_length) * angle) / 360`  - `sidebar_length` is the width of `.captcha_verify_slide--slidebar` - `icon_length` is the width of `.secsdk-captcha-drag-icon`
     * @param {File} outerImage The outer image file
     * @param {File} innerImage The inner image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeWhirlCaptcha: (outerImage: File, innerImage: File, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the rate limits for the provided API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveCaptchaCredits: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * CaptchasApi - functional programming interface
 * @export
 */
export declare const CaptchasApiFp: (configuration?: Configuration) => {
    /**
     * ## âš ï¸ Warning: Requires Business plan or higher  The icons captcha requires just one image & a prompt string.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/icon.png\" alt=\"Icons Captcha Example\" width=\"480\" />  ## Usage  The `prompt` is the text prompt provided by TikTok. The Icon captcha solution is provided as a list of points, where each point marks a location on the image that needs to be clicked. These points are expressed as ratios relative to the image\'s width and height. A point of (0.0, 0.0) corresponds to the imageâ€™s upper-left corner, while (1.0, 1.0) represents the lower-right corner. For reference, (0.5, 0.5) sits at the exact center.  The captcha image selector is `.captcha-verify-image`
     * @param {string} prompt The prompt string provided by TikTok
     * @param {File} captchaImage The uploaded image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeIconCaptcha(prompt: string, captchaImage: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IconCaptchaResponse>>;
    /**
     * The puzzle captcha requires two images  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/puzzle.png\" alt=\"Puzzle Piece Example\" width=\"480\" />  ## Usage  The solution to the puzzle captcha is the distance to move the slider to fit the puzzle piece into the background.  The `backgroundImage` is the full background image with the missing piece. The `pieceImage` is the small puzzle piece that needs to be fit into the background.  The captcha image selectors are: - Background: `.captcha-verify-image` - Piece: `#captcha-verify-image ~ div.cap-absolute > img`  The solution is the `x` proportion (0-1) of the width of the background image where the piece fits. It is 1:1 with the slider distance proportion.
     * @param {File} backgroundImage The uploaded background image file
     * @param {File} pieceImage The uploaded puzzle piece image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completePuzzleCaptcha(backgroundImage: File, pieceImage: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PuzzleCaptchaResponse>>;
    /**
     * The shapes captcha requires just one image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/threed.png\" alt=\"Shapes Captcha Example\" width=\"480\" />  ## Usage  The solution to the shapes captcha are two points that need to be clicked. To use it in the GUI, convert the proportions to pixel values based on the image size.  The `points` are returned as `x` and `y` proportions (0-1) of the width and height of the source image. The captcha image selector is `.captcha-verify-image`
     * @param {File} shapesCaptchaImage The uploaded image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeShapesCaptcha(shapesCaptchaImage: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShapesCaptchaResponse>>;
    /**
     * The whirl captcha requires two images: the outer image and the inner image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/rotate.png\" alt=\"Whirl Captcha Example\" width=\"480\" />  ## Usage  The solution to the whirl captcha is an angle from 0-360. To use it in the GUI, it must be converted to a slider distance:  `px = ((sidebar_length - icon_length) * angle) / 360`  - `sidebar_length` is the width of `.captcha_verify_slide--slidebar` - `icon_length` is the width of `.secsdk-captcha-drag-icon`
     * @param {File} outerImage The outer image file
     * @param {File} innerImage The inner image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeWhirlCaptcha(outerImage: File, innerImage: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WhirlCaptchaResponse>>;
    /**
     * Retrieve the rate limits for the provided API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveCaptchaCredits(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaptchaCreditsResponse>>;
};
/**
 * CaptchasApi - factory interface
 * @export
 */
export declare const CaptchasApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * ## âš ï¸ Warning: Requires Business plan or higher  The icons captcha requires just one image & a prompt string.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/icon.png\" alt=\"Icons Captcha Example\" width=\"480\" />  ## Usage  The `prompt` is the text prompt provided by TikTok. The Icon captcha solution is provided as a list of points, where each point marks a location on the image that needs to be clicked. These points are expressed as ratios relative to the image\'s width and height. A point of (0.0, 0.0) corresponds to the imageâ€™s upper-left corner, while (1.0, 1.0) represents the lower-right corner. For reference, (0.5, 0.5) sits at the exact center.  The captcha image selector is `.captcha-verify-image`
     * @param {string} prompt The prompt string provided by TikTok
     * @param {File} captchaImage The uploaded image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeIconCaptcha(prompt: string, captchaImage: File, options?: RawAxiosRequestConfig): AxiosPromise<IconCaptchaResponse>;
    /**
     * The puzzle captcha requires two images  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/puzzle.png\" alt=\"Puzzle Piece Example\" width=\"480\" />  ## Usage  The solution to the puzzle captcha is the distance to move the slider to fit the puzzle piece into the background.  The `backgroundImage` is the full background image with the missing piece. The `pieceImage` is the small puzzle piece that needs to be fit into the background.  The captcha image selectors are: - Background: `.captcha-verify-image` - Piece: `#captcha-verify-image ~ div.cap-absolute > img`  The solution is the `x` proportion (0-1) of the width of the background image where the piece fits. It is 1:1 with the slider distance proportion.
     * @param {File} backgroundImage The uploaded background image file
     * @param {File} pieceImage The uploaded puzzle piece image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completePuzzleCaptcha(backgroundImage: File, pieceImage: File, options?: RawAxiosRequestConfig): AxiosPromise<PuzzleCaptchaResponse>;
    /**
     * The shapes captcha requires just one image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/threed.png\" alt=\"Shapes Captcha Example\" width=\"480\" />  ## Usage  The solution to the shapes captcha are two points that need to be clicked. To use it in the GUI, convert the proportions to pixel values based on the image size.  The `points` are returned as `x` and `y` proportions (0-1) of the width and height of the source image. The captcha image selector is `.captcha-verify-image`
     * @param {File} shapesCaptchaImage The uploaded image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeShapesCaptcha(shapesCaptchaImage: File, options?: RawAxiosRequestConfig): AxiosPromise<ShapesCaptchaResponse>;
    /**
     * The whirl captcha requires two images: the outer image and the inner image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/rotate.png\" alt=\"Whirl Captcha Example\" width=\"480\" />  ## Usage  The solution to the whirl captcha is an angle from 0-360. To use it in the GUI, it must be converted to a slider distance:  `px = ((sidebar_length - icon_length) * angle) / 360`  - `sidebar_length` is the width of `.captcha_verify_slide--slidebar` - `icon_length` is the width of `.secsdk-captcha-drag-icon`
     * @param {File} outerImage The outer image file
     * @param {File} innerImage The inner image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeWhirlCaptcha(outerImage: File, innerImage: File, options?: RawAxiosRequestConfig): AxiosPromise<WhirlCaptchaResponse>;
    /**
     * Retrieve the rate limits for the provided API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveCaptchaCredits(options?: RawAxiosRequestConfig): AxiosPromise<CaptchaCreditsResponse>;
};
/**
 * CaptchasApi - object-oriented interface
 * @export
 * @class CaptchasApi
 * @extends {BaseAPI}
 */
export declare class CaptchasApi extends BaseAPI {
    /**
     * ## âš ï¸ Warning: Requires Business plan or higher  The icons captcha requires just one image & a prompt string.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/icon.png\" alt=\"Icons Captcha Example\" width=\"480\" />  ## Usage  The `prompt` is the text prompt provided by TikTok. The Icon captcha solution is provided as a list of points, where each point marks a location on the image that needs to be clicked. These points are expressed as ratios relative to the image\'s width and height. A point of (0.0, 0.0) corresponds to the imageâ€™s upper-left corner, while (1.0, 1.0) represents the lower-right corner. For reference, (0.5, 0.5) sits at the exact center.  The captcha image selector is `.captcha-verify-image`
     * @param {string} prompt The prompt string provided by TikTok
     * @param {File} captchaImage The uploaded image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaptchasApi
     */
    completeIconCaptcha(prompt: string, captchaImage: File, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IconCaptchaResponse, any>>;
    /**
     * The puzzle captcha requires two images  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/puzzle.png\" alt=\"Puzzle Piece Example\" width=\"480\" />  ## Usage  The solution to the puzzle captcha is the distance to move the slider to fit the puzzle piece into the background.  The `backgroundImage` is the full background image with the missing piece. The `pieceImage` is the small puzzle piece that needs to be fit into the background.  The captcha image selectors are: - Background: `.captcha-verify-image` - Piece: `#captcha-verify-image ~ div.cap-absolute > img`  The solution is the `x` proportion (0-1) of the width of the background image where the piece fits. It is 1:1 with the slider distance proportion.
     * @param {File} backgroundImage The uploaded background image file
     * @param {File} pieceImage The uploaded puzzle piece image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaptchasApi
     */
    completePuzzleCaptcha(backgroundImage: File, pieceImage: File, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<PuzzleCaptchaResponse, any>>;
    /**
     * The shapes captcha requires just one image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/threed.png\" alt=\"Shapes Captcha Example\" width=\"480\" />  ## Usage  The solution to the shapes captcha are two points that need to be clicked. To use it in the GUI, convert the proportions to pixel values based on the image size.  The `points` are returned as `x` and `y` proportions (0-1) of the width and height of the source image. The captcha image selector is `.captcha-verify-image`
     * @param {File} shapesCaptchaImage The uploaded image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaptchasApi
     */
    completeShapesCaptcha(shapesCaptchaImage: File, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<ShapesCaptchaResponse, any>>;
    /**
     * The whirl captcha requires two images: the outer image and the inner image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/rotate.png\" alt=\"Whirl Captcha Example\" width=\"480\" />  ## Usage  The solution to the whirl captcha is an angle from 0-360. To use it in the GUI, it must be converted to a slider distance:  `px = ((sidebar_length - icon_length) * angle) / 360`  - `sidebar_length` is the width of `.captcha_verify_slide--slidebar` - `icon_length` is the width of `.secsdk-captcha-drag-icon`
     * @param {File} outerImage The outer image file
     * @param {File} innerImage The inner image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaptchasApi
     */
    completeWhirlCaptcha(outerImage: File, innerImage: File, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<WhirlCaptchaResponse, any>>;
    /**
     * Retrieve the rate limits for the provided API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaptchasApi
     */
    retrieveCaptchaCredits(options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<CaptchaCreditsResponse, any>>;
}
/**
 * TikTokLIVEApi - axios parameter creator
 * @export
 */
export declare const TikTokLIVEApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
     * @param {string} [client] The client library identifier. Used for metrics.
     * @param {string} [roomId] The room ID to fetch the Webcast URL for.
     * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
     * @param {string} [cursor] Starting cursor for the webcast connection, if any
     * @param {string} [sessionId] Cookie - The account session ID from TikTok web
     * @param {string} [userAgent] Override the user agent used for signing and fetching
     * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
     * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
     * @param {SoaxProxyRegion} [country] Country code to make the request from.
     * @param {WebcastFetchPlatform} [platform] Platform to connect with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchWebcastURL: (client?: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, ttTargetIdc?: string, clientEnter?: boolean, country?: SoaxProxyRegion, platform?: WebcastFetchPlatform, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRateLimits: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Premium Route - A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
     * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveBulkLiveCheck: (retrieveBulkLiveCheckPayload: RetrieveBulkLiveCheckPayload, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve TikTok Live Room Gift List
     * @param {string} roomId The room ID of the TikTok LIVE session
     * @param {string} [webcastLanguage] Webcast language for locale-based fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveGiftInfo: (roomId: string, webcastLanguage?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomCover: (uniqueId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fetch Room ID for a given uniqueId & whether that user is live.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomId: (uniqueId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Premium Route - Retrieve TikTok Live Room Information
     * @param {string} uniqueId The unique identifier for the TikTok user or room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomInfo: (uniqueId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fetch TikTok LIVE Stream video given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
     * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomVideo: (uniqueId: string, streamType?: StreamType, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Premium Route - Fetch the TikTok LIVE webcast feed for a specific region. Gets a random sampling of creators for a region.
     * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveWebcastFeed: (region: OxyLabsProxyRegion, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Premium Route - Retrieve TikTok LIVE rankings for a specific region.
     * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
     * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
     * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
     * @param {RetrieveWebcastRankingsRankTypeEnum} rankType The type of ranking to fetch. See documentation for more details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveWebcastRankings: (region: OxyLabsProxyRegion, sessionId: string, ttTargetIdc: string, rankType: RetrieveWebcastRankingsRankTypeEnum, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Premium Route - Retrieve TikTok LIVE earnings for a specific user.
     * @param {string} uniqueId The unique ID (username) of the user to fetch earnings for.
     * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
     * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
     * @param {WebcastUserEarningsOutputPeriod} [period] Earnings period
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveWebcastUserEarnings: (uniqueId: string, sessionId: string, ttTargetIdc: string, period?: WebcastUserEarningsOutputPeriod, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Premium Route - Send a chat to a TikTok LIVE room.
     * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendRoomChat: (webcastRoomChatPayload: WebcastRoomChatPayload, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @param {SignTikTokUrlBody} signTikTokUrlBody
     * @param {string} [client]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signWebcastUrl: (signTikTokUrlBody: SignTikTokUrlBody, client?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TikTokLIVEApi - functional programming interface
 * @export
 */
export declare const TikTokLIVEApiFp: (configuration?: Configuration) => {
    /**
     * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
     * @param {string} [client] The client library identifier. Used for metrics.
     * @param {string} [roomId] The room ID to fetch the Webcast URL for.
     * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
     * @param {string} [cursor] Starting cursor for the webcast connection, if any
     * @param {string} [sessionId] Cookie - The account session ID from TikTok web
     * @param {string} [userAgent] Override the user agent used for signing and fetching
     * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
     * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
     * @param {SoaxProxyRegion} [country] Country code to make the request from.
     * @param {WebcastFetchPlatform} [platform] Platform to connect with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchWebcastURL(client?: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, ttTargetIdc?: string, clientEnter?: boolean, country?: SoaxProxyRegion, platform?: WebcastFetchPlatform, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>>;
    /**
     * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRateLimits(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRateLimits>>;
    /**
     * Premium Route - A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
     * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload: RetrieveBulkLiveCheckPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveBulkLiveCheckResponse>>;
    /**
     * Retrieve TikTok Live Room Gift List
     * @param {string} roomId The room ID of the TikTok LIVE session
     * @param {string} [webcastLanguage] Webcast language for locale-based fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveGiftInfo(roomId: string, webcastLanguage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastGiftInfoRouteResponse>>;
    /**
     * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomCover(uniqueId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JSONResponse>>;
    /**
     * Fetch Room ID for a given uniqueId & whether that user is live.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastRoomIdRouteResponse>>;
    /**
     * Premium Route - Retrieve TikTok Live Room Information
     * @param {string} uniqueId The unique identifier for the TikTok user or room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomInfo(uniqueId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastRoomInfoRouteResponse>>;
    /**
     * Fetch TikTok LIVE Stream video given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
     * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomVideo(uniqueId: string, streamType?: StreamType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JSONResponse>>;
    /**
     * Premium Route - Fetch the TikTok LIVE webcast feed for a specific region. Gets a random sampling of creators for a region.
     * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveWebcastFeed(region: OxyLabsProxyRegion, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastFeedRouteResponse>>;
    /**
     * Premium Route - Retrieve TikTok LIVE rankings for a specific region.
     * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
     * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
     * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
     * @param {RetrieveWebcastRankingsRankTypeEnum} rankType The type of ranking to fetch. See documentation for more details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveWebcastRankings(region: OxyLabsProxyRegion, sessionId: string, ttTargetIdc: string, rankType: RetrieveWebcastRankingsRankTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastRegionRankingsResponse>>;
    /**
     * Premium Route - Retrieve TikTok LIVE earnings for a specific user.
     * @param {string} uniqueId The unique ID (username) of the user to fetch earnings for.
     * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
     * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
     * @param {WebcastUserEarningsOutputPeriod} [period] Earnings period
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveWebcastUserEarnings(uniqueId: string, sessionId: string, ttTargetIdc: string, period?: WebcastUserEarningsOutputPeriod, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastUserEarningsResponse>>;
    /**
     * Premium Route - Send a chat to a TikTok LIVE room.
     * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendRoomChat(webcastRoomChatPayload: WebcastRoomChatPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastRoomChatRouteResponse>>;
    /**
     *
     * @param {SignTikTokUrlBody} signTikTokUrlBody
     * @param {string} [client]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signWebcastUrl(signTikTokUrlBody: SignTikTokUrlBody, client?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignWebcastUrl200Response>>;
};
/**
 * TikTokLIVEApi - factory interface
 * @export
 */
export declare const TikTokLIVEApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
     * @param {string} [client] The client library identifier. Used for metrics.
     * @param {string} [roomId] The room ID to fetch the Webcast URL for.
     * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
     * @param {string} [cursor] Starting cursor for the webcast connection, if any
     * @param {string} [sessionId] Cookie - The account session ID from TikTok web
     * @param {string} [userAgent] Override the user agent used for signing and fetching
     * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
     * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
     * @param {SoaxProxyRegion} [country] Country code to make the request from.
     * @param {WebcastFetchPlatform} [platform] Platform to connect with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchWebcastURL(client?: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, ttTargetIdc?: string, clientEnter?: boolean, country?: SoaxProxyRegion, platform?: WebcastFetchPlatform, options?: RawAxiosRequestConfig): AxiosPromise<object>;
    /**
     * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRateLimits(options?: RawAxiosRequestConfig): AxiosPromise<GetRateLimits>;
    /**
     * Premium Route - A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
     * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload: RetrieveBulkLiveCheckPayload, options?: RawAxiosRequestConfig): AxiosPromise<RetrieveBulkLiveCheckResponse>;
    /**
     * Retrieve TikTok Live Room Gift List
     * @param {string} roomId The room ID of the TikTok LIVE session
     * @param {string} [webcastLanguage] Webcast language for locale-based fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveGiftInfo(roomId: string, webcastLanguage?: string, options?: RawAxiosRequestConfig): AxiosPromise<WebcastGiftInfoRouteResponse>;
    /**
     * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomCover(uniqueId: string, options?: RawAxiosRequestConfig): AxiosPromise<JSONResponse>;
    /**
     * Fetch Room ID for a given uniqueId & whether that user is live.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig): AxiosPromise<WebcastRoomIdRouteResponse>;
    /**
     * Premium Route - Retrieve TikTok Live Room Information
     * @param {string} uniqueId The unique identifier for the TikTok user or room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomInfo(uniqueId: string, options?: RawAxiosRequestConfig): AxiosPromise<WebcastRoomInfoRouteResponse>;
    /**
     * Fetch TikTok LIVE Stream video given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
     * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomVideo(uniqueId: string, streamType?: StreamType, options?: RawAxiosRequestConfig): AxiosPromise<JSONResponse>;
    /**
     * Premium Route - Fetch the TikTok LIVE webcast feed for a specific region. Gets a random sampling of creators for a region.
     * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveWebcastFeed(region: OxyLabsProxyRegion, options?: RawAxiosRequestConfig): AxiosPromise<WebcastFeedRouteResponse>;
    /**
     * Premium Route - Retrieve TikTok LIVE rankings for a specific region.
     * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
     * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
     * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
     * @param {RetrieveWebcastRankingsRankTypeEnum} rankType The type of ranking to fetch. See documentation for more details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveWebcastRankings(region: OxyLabsProxyRegion, sessionId: string, ttTargetIdc: string, rankType: RetrieveWebcastRankingsRankTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<WebcastRegionRankingsResponse>;
    /**
     * Premium Route - Retrieve TikTok LIVE earnings for a specific user.
     * @param {string} uniqueId The unique ID (username) of the user to fetch earnings for.
     * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
     * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
     * @param {WebcastUserEarningsOutputPeriod} [period] Earnings period
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveWebcastUserEarnings(uniqueId: string, sessionId: string, ttTargetIdc: string, period?: WebcastUserEarningsOutputPeriod, options?: RawAxiosRequestConfig): AxiosPromise<WebcastUserEarningsResponse>;
    /**
     * Premium Route - Send a chat to a TikTok LIVE room.
     * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendRoomChat(webcastRoomChatPayload: WebcastRoomChatPayload, options?: RawAxiosRequestConfig): AxiosPromise<WebcastRoomChatRouteResponse>;
    /**
     *
     * @param {SignTikTokUrlBody} signTikTokUrlBody
     * @param {string} [client]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signWebcastUrl(signTikTokUrlBody: SignTikTokUrlBody, client?: string, options?: RawAxiosRequestConfig): AxiosPromise<SignWebcastUrl200Response>;
};
/**
 * TikTokLIVEApi - object-oriented interface
 * @export
 * @class TikTokLIVEApi
 * @extends {BaseAPI}
 */
export declare class TikTokLIVEApi extends BaseAPI {
    /**
     * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
     * @param {string} [client] The client library identifier. Used for metrics.
     * @param {string} [roomId] The room ID to fetch the Webcast URL for.
     * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
     * @param {string} [cursor] Starting cursor for the webcast connection, if any
     * @param {string} [sessionId] Cookie - The account session ID from TikTok web
     * @param {string} [userAgent] Override the user agent used for signing and fetching
     * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
     * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
     * @param {SoaxProxyRegion} [country] Country code to make the request from.
     * @param {WebcastFetchPlatform} [platform] Platform to connect with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    fetchWebcastURL(client?: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, ttTargetIdc?: string, clientEnter?: boolean, country?: SoaxProxyRegion, platform?: WebcastFetchPlatform, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<object, any>>;
    /**
     * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    getRateLimits(options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<GetRateLimits, any>>;
    /**
     * Premium Route - A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
     * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload: RetrieveBulkLiveCheckPayload, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<RetrieveBulkLiveCheckResponse, any>>;
    /**
     * Retrieve TikTok Live Room Gift List
     * @param {string} roomId The room ID of the TikTok LIVE session
     * @param {string} [webcastLanguage] Webcast language for locale-based fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveGiftInfo(roomId: string, webcastLanguage?: string, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<WebcastGiftInfoRouteResponse, any>>;
    /**
     * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveRoomCover(uniqueId: string, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<JSONResponse, any>>;
    /**
     * Fetch Room ID for a given uniqueId & whether that user is live.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<WebcastRoomIdRouteResponse, any>>;
    /**
     * Premium Route - Retrieve TikTok Live Room Information
     * @param {string} uniqueId The unique identifier for the TikTok user or room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveRoomInfo(uniqueId: string, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<WebcastRoomInfoRouteResponse, any>>;
    /**
     * Fetch TikTok LIVE Stream video given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
     * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveRoomVideo(uniqueId: string, streamType?: StreamType, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<JSONResponse, any>>;
    /**
     * Premium Route - Fetch the TikTok LIVE webcast feed for a specific region. Gets a random sampling of creators for a region.
     * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveWebcastFeed(region: OxyLabsProxyRegion, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<WebcastFeedRouteResponse, any>>;
    /**
     * Premium Route - Retrieve TikTok LIVE rankings for a specific region.
     * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
     * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
     * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
     * @param {RetrieveWebcastRankingsRankTypeEnum} rankType The type of ranking to fetch. See documentation for more details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveWebcastRankings(region: OxyLabsProxyRegion, sessionId: string, ttTargetIdc: string, rankType: RetrieveWebcastRankingsRankTypeEnum, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<WebcastRegionRankingsResponse, any>>;
    /**
     * Premium Route - Retrieve TikTok LIVE earnings for a specific user.
     * @param {string} uniqueId The unique ID (username) of the user to fetch earnings for.
     * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
     * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
     * @param {WebcastUserEarningsOutputPeriod} [period] Earnings period
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveWebcastUserEarnings(uniqueId: string, sessionId: string, ttTargetIdc: string, period?: WebcastUserEarningsOutputPeriod, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<WebcastUserEarningsResponse, any>>;
    /**
     * Premium Route - Send a chat to a TikTok LIVE room.
     * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    sendRoomChat(webcastRoomChatPayload: WebcastRoomChatPayload, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<WebcastRoomChatRouteResponse, any>>;
    /**
     *
     * @param {SignTikTokUrlBody} signTikTokUrlBody
     * @param {string} [client]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    signWebcastUrl(signTikTokUrlBody: SignTikTokUrlBody, client?: string, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<SignWebcastUrl200Response, any>>;
}
/**
 * @export
 */
export declare const RetrieveWebcastRankingsRankTypeEnum: {
    readonly FansTeamRank: "FANS_TEAM_RANK";
    readonly DailyRank: "DAILY_RANK";
};
export type RetrieveWebcastRankingsRankTypeEnum = typeof RetrieveWebcastRankingsRankTypeEnum[keyof typeof RetrieveWebcastRankingsRankTypeEnum];
//# sourceMappingURL=api.d.ts.map