"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * The Sign Serverâ„¢
 * Sign Server API Documentation
 *
 * The version of the OpenAPI document: dev
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetrieveWebcastRankingsRankTypeEnum = exports.TikTokLIVEApi = exports.TikTokLIVEApiFactory = exports.TikTokLIVEApiFp = exports.TikTokLIVEApiAxiosParamCreator = exports.CaptchasApi = exports.CaptchasApiFactory = exports.CaptchasApiFp = exports.CaptchasApiAxiosParamCreator = exports.UpdateKeyUpdateByEnum = exports.GetKeyRetrieveByEnum = exports.DeleteKeyDeleteByEnum = exports.AuthenticationApi = exports.AuthenticationApiFactory = exports.AuthenticationApiFp = exports.AuthenticationApiAxiosParamCreator = exports.AnalyticsApi = exports.AnalyticsApiFactory = exports.AnalyticsApiFp = exports.AnalyticsApiAxiosParamCreator = exports.AlertsApi = exports.AlertsApiFactory = exports.AlertsApiFp = exports.AlertsApiAxiosParamCreator = exports.AlertTargetsApi = exports.AlertTargetsApiFactory = exports.AlertTargetsApiFp = exports.AlertTargetsApiAxiosParamCreator = exports.RetrieveAggregateUsagePeriodEnum = exports.AccountsApi = exports.AccountsApiFactory = exports.AccountsApiFp = exports.AccountsApiAxiosParamCreator = exports.WebcastUserEarningsOutputPeriod = exports.WebcastUserEarningsOutputEarningsEstimateCurrencyEnum = exports.WebcastFetchPlatform = exports.StreamType = exports.SoaxProxyRegion = exports.SignTikTokUrlBodyTypeEnum = exports.SignTikTokUrlBodyMethodEnum = exports.PeerRole = exports.PeerPresenceTypeEnum = exports.OxyLabsProxyRegion = exports.AlertTargetStatus = exports.AlertTargetFormat = exports.AccountScopes = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 *
 * @export
 * @enum {number}
 */
exports.AccountScopes = {
    NUMBER_MINUS_1: -1,
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_10: 10,
    NUMBER_11: 11,
    NUMBER_8: 8,
    NUMBER_6: 6,
    NUMBER_12: 12,
    NUMBER_13: 13,
    NUMBER_14: 14,
    NUMBER_15: 15
};
/**
 *
 * @export
 * @enum {number}
 */
exports.AlertTargetFormat = {
    NUMBER_1: 1
};
/**
 *
 * @export
 * @enum {number}
 */
exports.AlertTargetStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_4: 4
};
/**
 *
 * @export
 * @enum {string}
 */
exports.OxyLabsProxyRegion = {
    Us: 'US',
    Gb: 'GB',
    De: 'DE',
    Ro: 'RO',
    Es: 'ES',
    Be: 'BE',
    Fr: 'FR',
    Ca: 'CA',
    Jp: 'JP',
    Br: 'BR',
    Mx: 'MX',
    Co: 'CO',
    Ar: 'AR',
    Cl: 'CL',
    Au: 'AU',
    Kr: 'KR',
    Pe: 'PE',
    Pl: 'PL',
    Sg: 'SG',
    It: 'IT'
};
exports.PeerPresenceTypeEnum = {
    Api: 'api',
    Agent: 'agent'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.PeerRole = {
    Public: 'public',
    Enterprise: 'enterprise',
    Staging: 'staging'
};
exports.SignTikTokUrlBodyMethodEnum = {
    Get: 'GET',
    Post: 'POST',
    Options: 'OPTIONS',
    Put: 'PUT',
    Delete: 'DELETE',
    Patch: 'PATCH',
    Head: 'HEAD'
};
exports.SignTikTokUrlBodyTypeEnum = {
    Fetch: 'fetch',
    Xhr: 'xhr'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SoaxProxyRegion = {
    De: 'DE',
    Es: 'ES',
    Fr: 'FR',
    Gb: 'GB',
    Pl: 'PL'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.StreamType = {
    HlsLd: 'hls_ld',
    HlsSd: 'hls_sd',
    FlvLd: 'flv_ld',
    FlvSd: 'flv_sd'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.WebcastFetchPlatform = {
    Mobile: 'mobile',
    Web: 'web'
};
exports.WebcastUserEarningsOutputEarningsEstimateCurrencyEnum = {
    Usd: 'USD'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.WebcastUserEarningsOutputPeriod = {
    Daily: 'daily'
};
/**
 * AccountsApi - axios parameter creator
 * @export
 */
const AccountsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countSignUsage: async (accountId, from, to, apiKeyId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('countSignUsage', 'accountId', accountId);
            // verify required parameter 'from' is not null or undefined
            (0, common_1.assertParamExists)('countSignUsage', 'from', from);
            // verify required parameter 'to' is not null or undefined
            (0, common_1.assertParamExists)('countSignUsage', 'to', to);
            const localVarPath = `/accounts/{account_id}/usage/sign_usage/page_count`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (from !== undefined) {
                localVarQueryParameter['from'] = (from instanceof Date) ?
                    from.toISOString() :
                    from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = (to instanceof Date) ?
                    to.toISOString() :
                    to;
            }
            if (apiKeyId !== undefined) {
                localVarQueryParameter['api_key_id'] = apiKeyId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUsage: async (accountId, from, to, apiKeyId, page, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getSignUsage', 'accountId', accountId);
            // verify required parameter 'from' is not null or undefined
            (0, common_1.assertParamExists)('getSignUsage', 'from', from);
            // verify required parameter 'to' is not null or undefined
            (0, common_1.assertParamExists)('getSignUsage', 'to', to);
            const localVarPath = `/accounts/{account_id}/usage/sign_usage`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (from !== undefined) {
                localVarQueryParameter['from'] = (from instanceof Date) ?
                    from.toISOString() :
                    from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = (to instanceof Date) ?
                    to.toISOString() :
                    to;
            }
            if (apiKeyId !== undefined) {
                localVarQueryParameter['api_key_id'] = apiKeyId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccountSelf: async (options = {}) => {
            const localVarPath = `/accounts/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAggregateUsage: async (accountId, period, value, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAggregateUsage', 'accountId', accountId);
            // verify required parameter 'period' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAggregateUsage', 'period', period);
            // verify required parameter 'value' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAggregateUsage', 'value', value);
            const localVarPath = `/accounts/{account_id}/usage/sign_usage/aggregate`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }
            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AccountsApiAxiosParamCreator = AccountsApiAxiosParamCreator;
/**
 * AccountsApi - functional programming interface
 * @export
 */
const AccountsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AccountsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countSignUsage(accountId, from, to, apiKeyId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countSignUsage(accountId, from, to, apiKeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AccountsApi.countSignUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignUsage(accountId, from, to, apiKeyId, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignUsage(accountId, from, to, apiKeyId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AccountsApi.getSignUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAccountSelf(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAccountSelf(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AccountsApi.retrieveAccountSelf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAggregateUsage(accountId, period, value, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAggregateUsage(accountId, period, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AccountsApi.retrieveAggregateUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AccountsApiFp = AccountsApiFp;
/**
 * AccountsApi - factory interface
 * @export
 */
const AccountsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AccountsApiFp)(configuration);
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countSignUsage(accountId, from, to, apiKeyId, options) {
            return localVarFp.countSignUsage(accountId, from, to, apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUsage(accountId, from, to, apiKeyId, page, options) {
            return localVarFp.getSignUsage(accountId, from, to, apiKeyId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccountSelf(options) {
            return localVarFp.retrieveAccountSelf(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAggregateUsage(accountId, period, value, options) {
            return localVarFp.retrieveAggregateUsage(accountId, period, value, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AccountsApiFactory = AccountsApiFactory;
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
class AccountsApi extends base_1.BaseAPI {
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    countSignUsage(accountId, from, to, apiKeyId, options) {
        return (0, exports.AccountsApiFp)(this.configuration).countSignUsage(accountId, from, to, apiKeyId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {number} [page] Page number to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getSignUsage(accountId, from, to, apiKeyId, page, options) {
        return (0, exports.AccountsApiFp)(this.configuration).getSignUsage(accountId, from, to, apiKeyId, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an account from the Sign API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    retrieveAccountSelf(options) {
        return (0, exports.AccountsApiFp)(this.configuration).retrieveAccountSelf(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
     * @param {number} value The value for the period (either hours or numbers)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    retrieveAggregateUsage(accountId, period, value, options) {
        return (0, exports.AccountsApiFp)(this.configuration).retrieveAggregateUsage(accountId, period, value, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AccountsApi = AccountsApi;
/**
 * @export
 */
exports.RetrieveAggregateUsagePeriodEnum = {
    Hour: 'hour',
    Day: 'day'
};
/**
 * AlertTargetsApi - axios parameter creator
 * @export
 */
const AlertTargetsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertTarget: async (accountId, alertId, createAlertTargetPayload, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createAlertTarget', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('createAlertTarget', 'alertId', alertId);
            // verify required parameter 'createAlertTargetPayload' is not null or undefined
            (0, common_1.assertParamExists)('createAlertTarget', 'createAlertTargetPayload', createAlertTargetPayload);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAlertTargetPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertTarget: async (accountId, alertId, targetId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlertTarget', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlertTarget', 'alertId', alertId);
            // verify required parameter 'targetId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlertTarget', 'targetId', targetId);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/{target_id}/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)))
                .replace(`{${"target_id"}}`, encodeURIComponent(String(targetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertTargets: async (accountId, alertId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('listAlertTargets', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('listAlertTargets', 'alertId', alertId);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAlertTarget: async (accountId, alertId, targetId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('testAlertTarget', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('testAlertTarget', 'alertId', alertId);
            // verify required parameter 'targetId' is not null or undefined
            (0, common_1.assertParamExists)('testAlertTarget', 'targetId', targetId);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/{target_id}/test`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)))
                .replace(`{${"target_id"}}`, encodeURIComponent(String(targetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AlertTargetsApiAxiosParamCreator = AlertTargetsApiAxiosParamCreator;
/**
 * AlertTargetsApi - functional programming interface
 * @export
 */
const AlertTargetsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AlertTargetsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlertTarget(accountId, alertId, createAlertTargetPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlertTarget(accountId, alertId, createAlertTargetPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertTargetsApi.createAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlertTarget(accountId, alertId, targetId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlertTarget(accountId, alertId, targetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertTargetsApi.deleteAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlertTargets(accountId, alertId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlertTargets(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertTargetsApi.listAlertTargets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testAlertTarget(accountId, alertId, targetId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testAlertTarget(accountId, alertId, targetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertTargetsApi.testAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AlertTargetsApiFp = AlertTargetsApiFp;
/**
 * AlertTargetsApi - factory interface
 * @export
 */
const AlertTargetsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AlertTargetsApiFp)(configuration);
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertTarget(accountId, alertId, createAlertTargetPayload, options) {
            return localVarFp.createAlertTarget(accountId, alertId, createAlertTargetPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertTarget(accountId, alertId, targetId, options) {
            return localVarFp.deleteAlertTarget(accountId, alertId, targetId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertTargets(accountId, alertId, options) {
            return localVarFp.listAlertTargets(accountId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAlertTarget(accountId, alertId, targetId, options) {
            return localVarFp.testAlertTarget(accountId, alertId, targetId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AlertTargetsApiFactory = AlertTargetsApiFactory;
/**
 * AlertTargetsApi - object-oriented interface
 * @export
 * @class AlertTargetsApi
 * @extends {BaseAPI}
 */
class AlertTargetsApi extends base_1.BaseAPI {
    /**
     * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
     * @param {number} accountId The ID of the account to create the alert target for
     * @param {number} alertId The ID of the alert to create the target for
     * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    createAlertTarget(accountId, alertId, createAlertTargetPayload, options) {
        return (0, exports.AlertTargetsApiFp)(this.configuration).createAlertTarget(accountId, alertId, createAlertTargetPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete an alert target from the Sign API
     * @param {number} accountId The ID of the account to delete the alert target from
     * @param {number} alertId The ID of the alert to delete the target from
     * @param {number} targetId The ID of the target to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    deleteAlertTarget(accountId, alertId, targetId, options) {
        return (0, exports.AlertTargetsApiFp)(this.configuration).deleteAlertTarget(accountId, alertId, targetId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all alert targets for a specific alert
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert to list targets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    listAlertTargets(accountId, alertId, options) {
        return (0, exports.AlertTargetsApiFp)(this.configuration).listAlertTargets(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Test an alert target
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert that the target belongs to
     * @param {number} targetId The target to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    testAlertTarget(accountId, alertId, targetId, options) {
        return (0, exports.AlertTargetsApiFp)(this.configuration).testAlertTarget(accountId, alertId, targetId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AlertTargetsApi = AlertTargetsApi;
/**
 * AlertsApi - axios parameter creator
 * @export
 */
const AlertsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert: async (accountId, createAlertRequest, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createAlert', 'accountId', accountId);
            // verify required parameter 'createAlertRequest' is not null or undefined
            (0, common_1.assertParamExists)('createAlert', 'createAlertRequest', createAlertRequest);
            const localVarPath = `/accounts/{account_id}/alerts/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAlertRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert: async (accountId, alertId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlert', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlert', 'alertId', alertId);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} accountId
         * @param {number} [page]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts: async (accountId, page, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('listAlerts', 'accountId', accountId);
            const localVarPath = `/accounts/{account_id}/alerts/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAlert: async (accountId, alertId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAlert', 'accountId', accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAlert', 'alertId', alertId);
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/retrieve`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AlertsApiAxiosParamCreator = AlertsApiAxiosParamCreator;
/**
 * AlertsApi - functional programming interface
 * @export
 */
const AlertsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AlertsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlert(accountId, createAlertRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlert(accountId, createAlertRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.createAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlert(accountId, alertId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlert(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.deleteAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {number} accountId
         * @param {number} [page]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlerts(accountId, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlerts(accountId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.listAlerts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAlert(accountId, alertId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAlert(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.retrieveAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AlertsApiFp = AlertsApiFp;
/**
 * AlertsApi - factory interface
 * @export
 */
const AlertsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AlertsApiFp)(configuration);
    return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert(accountId, createAlertRequest, options) {
            return localVarFp.createAlert(accountId, createAlertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert(accountId, alertId, options) {
            return localVarFp.deleteAlert(accountId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} accountId
         * @param {number} [page]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts(accountId, page, options) {
            return localVarFp.listAlerts(accountId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAlert(accountId, alertId, options) {
            return localVarFp.retrieveAlert(accountId, alertId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AlertsApiFactory = AlertsApiFactory;
/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
class AlertsApi extends base_1.BaseAPI {
    /**
     * Create a creator alert. These Alerts are used to notify users of a new livestream.
     * @param {number} accountId The ID of the account to create the alert for
     * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    createAlert(accountId, createAlertRequest, options) {
        return (0, exports.AlertsApiFp)(this.configuration).createAlert(accountId, createAlertRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete an alert from the Sign API
     * @param {number} accountId The ID of the account to delete the alert from
     * @param {number} alertId The ID of the alert to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    deleteAlert(accountId, alertId, options) {
        return (0, exports.AlertsApiFp)(this.configuration).deleteAlert(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} accountId
     * @param {number} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    listAlerts(accountId, page, options) {
        return (0, exports.AlertsApiFp)(this.configuration).listAlerts(accountId, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a specific alert by its ID
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The ID of the alert to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    retrieveAlert(accountId, alertId, options) {
        return (0, exports.AlertsApiFp)(this.configuration).retrieveAlert(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AlertsApi = AlertsApi;
/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
const AnalyticsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAgents: async (options = {}) => {
            const localVarPath = `/analytics/agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts: async (options = {}) => {
            const localVarPath = `/analytics/hosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AnalyticsApiAxiosParamCreator = AnalyticsApiAxiosParamCreator;
/**
 * AnalyticsApi - functional programming interface
 * @export
 */
const AnalyticsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AnalyticsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAgents(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAgents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AnalyticsApi.fetchAgents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHosts(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHosts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AnalyticsApi.getHosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AnalyticsApiFp = AnalyticsApiFp;
/**
 * AnalyticsApi - factory interface
 * @export
 */
const AnalyticsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AnalyticsApiFp)(configuration);
    return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAgents(options) {
            return localVarFp.fetchAgents(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts(options) {
            return localVarFp.getHosts(options).then((request) => request(axios, basePath));
        },
    };
};
exports.AnalyticsApiFactory = AnalyticsApiFactory;
/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
class AnalyticsApi extends base_1.BaseAPI {
    /**
     * Retrieve the currently connected agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    fetchAgents(options) {
        return (0, exports.AnalyticsApiFp)(this.configuration).fetchAgents(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the list of API hosts (used for horizontal scaling)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getHosts(options) {
        return (0, exports.AnalyticsApiFp)(this.configuration).getHosts(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AnalyticsApi = AnalyticsApi;
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
const AuthenticationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJWT: async (accountId, jWTCreateConfig, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createJWT', 'accountId', accountId);
            // verify required parameter 'jWTCreateConfig' is not null or undefined
            (0, common_1.assertParamExists)('createJWT', 'jWTCreateConfig', jWTCreateConfig);
            const localVarPath = `/accounts/{account_id}/jwt/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jWTCreateConfig, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (accountId, createKeyPayload, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createKey', 'accountId', accountId);
            // verify required parameter 'createKeyPayload' is not null or undefined
            (0, common_1.assertParamExists)('createKey', 'createKeyPayload', createKeyPayload);
            const localVarPath = `/accounts/{account_id}/api_keys/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createKeyPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey: async (accountId, deleteBy, deleteParam, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('deleteKey', 'accountId', accountId);
            // verify required parameter 'deleteBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteKey', 'deleteBy', deleteBy);
            // verify required parameter 'deleteParam' is not null or undefined
            (0, common_1.assertParamExists)('deleteKey', 'deleteParam', deleteParam);
            const localVarPath = `/accounts/{account_id}/api_keys/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (deleteBy !== undefined) {
                localVarQueryParameter['delete_by'] = deleteBy;
            }
            if (deleteParam !== undefined) {
                localVarQueryParameter['delete_param'] = deleteParam;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey: async (accountId, retrieveParam, retrieveBy, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getKey', 'accountId', accountId);
            // verify required parameter 'retrieveParam' is not null or undefined
            (0, common_1.assertParamExists)('getKey', 'retrieveParam', retrieveParam);
            const localVarPath = `/accounts/{account_id}/api_keys/retrieve`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (retrieveBy !== undefined) {
                localVarQueryParameter['retrieve_by'] = retrieveBy;
            }
            if (retrieveParam !== undefined) {
                localVarQueryParameter['retrieve_param'] = retrieveParam;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeys: async (accountId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('listKeys', 'accountId', accountId);
            const localVarPath = `/accounts/{account_id}/api_keys/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey: async (accountId, updateBy, updateParam, updateKeyPayload, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('updateKey', 'accountId', accountId);
            // verify required parameter 'updateBy' is not null or undefined
            (0, common_1.assertParamExists)('updateKey', 'updateBy', updateBy);
            // verify required parameter 'updateParam' is not null or undefined
            (0, common_1.assertParamExists)('updateKey', 'updateParam', updateParam);
            // verify required parameter 'updateKeyPayload' is not null or undefined
            (0, common_1.assertParamExists)('updateKey', 'updateKeyPayload', updateKeyPayload);
            const localVarPath = `/accounts/{account_id}/api_keys/update`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (updateBy !== undefined) {
                localVarQueryParameter['update_by'] = updateBy;
            }
            if (updateParam !== undefined) {
                localVarQueryParameter['update_param'] = updateParam;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateKeyPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AuthenticationApiAxiosParamCreator = AuthenticationApiAxiosParamCreator;
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
const AuthenticationApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AuthenticationApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJWT(accountId, jWTCreateConfig, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJWT(accountId, jWTCreateConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.createJWT']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(accountId, createKeyPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKey(accountId, createKeyPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.createKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKey(accountId, deleteBy, deleteParam, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKey(accountId, deleteBy, deleteParam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.deleteKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKey(accountId, retrieveParam, retrieveBy, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKey(accountId, retrieveParam, retrieveBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.getKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKeys(accountId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKeys(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.listKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKey(accountId, updateBy, updateParam, updateKeyPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKey(accountId, updateBy, updateParam, updateKeyPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AuthenticationApi.updateKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AuthenticationApiFp = AuthenticationApiFp;
/**
 * AuthenticationApi - factory interface
 * @export
 */
const AuthenticationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AuthenticationApiFp)(configuration);
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJWT(accountId, jWTCreateConfig, options) {
            return localVarFp.createJWT(accountId, jWTCreateConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(accountId, createKeyPayload, options) {
            return localVarFp.createKey(accountId, createKeyPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey(accountId, deleteBy, deleteParam, options) {
            return localVarFp.deleteKey(accountId, deleteBy, deleteParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey(accountId, retrieveParam, retrieveBy, options) {
            return localVarFp.getKey(accountId, retrieveParam, retrieveBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeys(accountId, options) {
            return localVarFp.listKeys(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey(accountId, updateBy, updateParam, updateKeyPayload, options) {
            return localVarFp.updateKey(accountId, updateBy, updateParam, updateKeyPayload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AuthenticationApiFactory = AuthenticationApiFactory;
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
class AuthenticationApi extends base_1.BaseAPI {
    /**
     * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
     * @param {number} accountId The ID of the account to create the JWT for
     * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    createJWT(accountId, jWTCreateConfig, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).createJWT(accountId, jWTCreateConfig, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new API key
     * @param {number} accountId The ID of the account to create the key for
     * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    createKey(accountId, createKeyPayload, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).createKey(accountId, createKeyPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to delete the key for
     * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
     * @param {string} deleteParam The API key field value to delete by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    deleteKey(accountId, deleteBy, deleteParam, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).deleteKey(accountId, deleteBy, deleteParam, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {string} retrieveParam The API key field value to retrieve by
     * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    getKey(accountId, retrieveParam, retrieveBy, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).getKey(accountId, retrieveParam, retrieveBy, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    listKeys(accountId, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).listKeys(accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update an existing API key
     * @param {number} accountId The account to update the key for
     * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
     * @param {string} updateParam The API key field value to update by
     * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    updateKey(accountId, updateBy, updateParam, updateKeyPayload, options) {
        return (0, exports.AuthenticationApiFp)(this.configuration).updateKey(accountId, updateBy, updateParam, updateKeyPayload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AuthenticationApi = AuthenticationApi;
/**
 * @export
 */
exports.DeleteKeyDeleteByEnum = {
    Value: 'value',
    Id: 'id'
};
/**
 * @export
 */
exports.GetKeyRetrieveByEnum = {
    Value: 'value',
    Id: 'id'
};
/**
 * @export
 */
exports.UpdateKeyUpdateByEnum = {
    Value: 'value',
    Id: 'id'
};
/**
 * CaptchasApi - axios parameter creator
 * @export
 */
const CaptchasApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * ## âš ï¸ Warning: Requires Business plan or higher  The icons captcha requires just one image & a prompt string.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/icon.png\" alt=\"Icons Captcha Example\" width=\"480\" />  ## Usage  The `prompt` is the text prompt provided by TikTok. The Icon captcha solution is provided as a list of points, where each point marks a location on the image that needs to be clicked. These points are expressed as ratios relative to the image\'s width and height. A point of (0.0, 0.0) corresponds to the imageâ€™s upper-left corner, while (1.0, 1.0) represents the lower-right corner. For reference, (0.5, 0.5) sits at the exact center.  The captcha image selector is `.captcha-verify-image`
         * @param {string} prompt The prompt string provided by TikTok
         * @param {File} captchaImage The uploaded image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeIconCaptcha: async (prompt, captchaImage, options = {}) => {
            // verify required parameter 'prompt' is not null or undefined
            (0, common_1.assertParamExists)('completeIconCaptcha', 'prompt', prompt);
            // verify required parameter 'captchaImage' is not null or undefined
            (0, common_1.assertParamExists)('completeIconCaptcha', 'captchaImage', captchaImage);
            const localVarPath = `/tiktok/captchas/icons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (prompt !== undefined) {
                localVarQueryParameter['prompt'] = prompt;
            }
            if (captchaImage !== undefined) {
                localVarFormParams.append('captchaImage', captchaImage);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The puzzle captcha requires two images  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/puzzle.png\" alt=\"Puzzle Piece Example\" width=\"480\" />  ## Usage  The solution to the puzzle captcha is the distance to move the slider to fit the puzzle piece into the background.  The `backgroundImage` is the full background image with the missing piece. The `pieceImage` is the small puzzle piece that needs to be fit into the background.  The captcha image selectors are: - Background: `.captcha-verify-image` - Piece: `#captcha-verify-image ~ div.cap-absolute > img`  The solution is the `x` proportion (0-1) of the width of the background image where the piece fits. It is 1:1 with the slider distance proportion.
         * @param {File} backgroundImage The uploaded background image file
         * @param {File} pieceImage The uploaded puzzle piece image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completePuzzleCaptcha: async (backgroundImage, pieceImage, options = {}) => {
            // verify required parameter 'backgroundImage' is not null or undefined
            (0, common_1.assertParamExists)('completePuzzleCaptcha', 'backgroundImage', backgroundImage);
            // verify required parameter 'pieceImage' is not null or undefined
            (0, common_1.assertParamExists)('completePuzzleCaptcha', 'pieceImage', pieceImage);
            const localVarPath = `/tiktok/captchas/puzzle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (backgroundImage !== undefined) {
                localVarFormParams.append('backgroundImage', backgroundImage);
            }
            if (pieceImage !== undefined) {
                localVarFormParams.append('pieceImage', pieceImage);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The shapes captcha requires just one image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/threed.png\" alt=\"Shapes Captcha Example\" width=\"480\" />  ## Usage  The solution to the shapes captcha are two points that need to be clicked. To use it in the GUI, convert the proportions to pixel values based on the image size.  The `points` are returned as `x` and `y` proportions (0-1) of the width and height of the source image. The captcha image selector is `.captcha-verify-image`
         * @param {File} shapesCaptchaImage The uploaded image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeShapesCaptcha: async (shapesCaptchaImage, options = {}) => {
            // verify required parameter 'shapesCaptchaImage' is not null or undefined
            (0, common_1.assertParamExists)('completeShapesCaptcha', 'shapesCaptchaImage', shapesCaptchaImage);
            const localVarPath = `/tiktok/captchas/shapes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (shapesCaptchaImage !== undefined) {
                localVarFormParams.append('shapesCaptchaImage', shapesCaptchaImage);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The whirl captcha requires two images: the outer image and the inner image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/rotate.png\" alt=\"Whirl Captcha Example\" width=\"480\" />  ## Usage  The solution to the whirl captcha is an angle from 0-360. To use it in the GUI, it must be converted to a slider distance:  `px = ((sidebar_length - icon_length) * angle) / 360`  - `sidebar_length` is the width of `.captcha_verify_slide--slidebar` - `icon_length` is the width of `.secsdk-captcha-drag-icon`
         * @param {File} outerImage The outer image file
         * @param {File} innerImage The inner image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeWhirlCaptcha: async (outerImage, innerImage, options = {}) => {
            // verify required parameter 'outerImage' is not null or undefined
            (0, common_1.assertParamExists)('completeWhirlCaptcha', 'outerImage', outerImage);
            // verify required parameter 'innerImage' is not null or undefined
            (0, common_1.assertParamExists)('completeWhirlCaptcha', 'innerImage', innerImage);
            const localVarPath = `/tiktok/captchas/whirl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (outerImage !== undefined) {
                localVarFormParams.append('outerImage', outerImage);
            }
            if (innerImage !== undefined) {
                localVarFormParams.append('innerImage', innerImage);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the rate limits for the provided API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCaptchaCredits: async (options = {}) => {
            const localVarPath = `/tiktok/captchas/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.CaptchasApiAxiosParamCreator = CaptchasApiAxiosParamCreator;
/**
 * CaptchasApi - functional programming interface
 * @export
 */
const CaptchasApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CaptchasApiAxiosParamCreator)(configuration);
    return {
        /**
         * ## âš ï¸ Warning: Requires Business plan or higher  The icons captcha requires just one image & a prompt string.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/icon.png\" alt=\"Icons Captcha Example\" width=\"480\" />  ## Usage  The `prompt` is the text prompt provided by TikTok. The Icon captcha solution is provided as a list of points, where each point marks a location on the image that needs to be clicked. These points are expressed as ratios relative to the image\'s width and height. A point of (0.0, 0.0) corresponds to the imageâ€™s upper-left corner, while (1.0, 1.0) represents the lower-right corner. For reference, (0.5, 0.5) sits at the exact center.  The captcha image selector is `.captcha-verify-image`
         * @param {string} prompt The prompt string provided by TikTok
         * @param {File} captchaImage The uploaded image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeIconCaptcha(prompt, captchaImage, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeIconCaptcha(prompt, captchaImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['CaptchasApi.completeIconCaptcha']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The puzzle captcha requires two images  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/puzzle.png\" alt=\"Puzzle Piece Example\" width=\"480\" />  ## Usage  The solution to the puzzle captcha is the distance to move the slider to fit the puzzle piece into the background.  The `backgroundImage` is the full background image with the missing piece. The `pieceImage` is the small puzzle piece that needs to be fit into the background.  The captcha image selectors are: - Background: `.captcha-verify-image` - Piece: `#captcha-verify-image ~ div.cap-absolute > img`  The solution is the `x` proportion (0-1) of the width of the background image where the piece fits. It is 1:1 with the slider distance proportion.
         * @param {File} backgroundImage The uploaded background image file
         * @param {File} pieceImage The uploaded puzzle piece image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completePuzzleCaptcha(backgroundImage, pieceImage, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completePuzzleCaptcha(backgroundImage, pieceImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['CaptchasApi.completePuzzleCaptcha']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The shapes captcha requires just one image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/threed.png\" alt=\"Shapes Captcha Example\" width=\"480\" />  ## Usage  The solution to the shapes captcha are two points that need to be clicked. To use it in the GUI, convert the proportions to pixel values based on the image size.  The `points` are returned as `x` and `y` proportions (0-1) of the width and height of the source image. The captcha image selector is `.captcha-verify-image`
         * @param {File} shapesCaptchaImage The uploaded image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeShapesCaptcha(shapesCaptchaImage, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeShapesCaptcha(shapesCaptchaImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['CaptchasApi.completeShapesCaptcha']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The whirl captcha requires two images: the outer image and the inner image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/rotate.png\" alt=\"Whirl Captcha Example\" width=\"480\" />  ## Usage  The solution to the whirl captcha is an angle from 0-360. To use it in the GUI, it must be converted to a slider distance:  `px = ((sidebar_length - icon_length) * angle) / 360`  - `sidebar_length` is the width of `.captcha_verify_slide--slidebar` - `icon_length` is the width of `.secsdk-captcha-drag-icon`
         * @param {File} outerImage The outer image file
         * @param {File} innerImage The inner image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeWhirlCaptcha(outerImage, innerImage, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeWhirlCaptcha(outerImage, innerImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['CaptchasApi.completeWhirlCaptcha']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the rate limits for the provided API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCaptchaCredits(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCaptchaCredits(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['CaptchasApi.retrieveCaptchaCredits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.CaptchasApiFp = CaptchasApiFp;
/**
 * CaptchasApi - factory interface
 * @export
 */
const CaptchasApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CaptchasApiFp)(configuration);
    return {
        /**
         * ## âš ï¸ Warning: Requires Business plan or higher  The icons captcha requires just one image & a prompt string.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/icon.png\" alt=\"Icons Captcha Example\" width=\"480\" />  ## Usage  The `prompt` is the text prompt provided by TikTok. The Icon captcha solution is provided as a list of points, where each point marks a location on the image that needs to be clicked. These points are expressed as ratios relative to the image\'s width and height. A point of (0.0, 0.0) corresponds to the imageâ€™s upper-left corner, while (1.0, 1.0) represents the lower-right corner. For reference, (0.5, 0.5) sits at the exact center.  The captcha image selector is `.captcha-verify-image`
         * @param {string} prompt The prompt string provided by TikTok
         * @param {File} captchaImage The uploaded image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeIconCaptcha(prompt, captchaImage, options) {
            return localVarFp.completeIconCaptcha(prompt, captchaImage, options).then((request) => request(axios, basePath));
        },
        /**
         * The puzzle captcha requires two images  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/puzzle.png\" alt=\"Puzzle Piece Example\" width=\"480\" />  ## Usage  The solution to the puzzle captcha is the distance to move the slider to fit the puzzle piece into the background.  The `backgroundImage` is the full background image with the missing piece. The `pieceImage` is the small puzzle piece that needs to be fit into the background.  The captcha image selectors are: - Background: `.captcha-verify-image` - Piece: `#captcha-verify-image ~ div.cap-absolute > img`  The solution is the `x` proportion (0-1) of the width of the background image where the piece fits. It is 1:1 with the slider distance proportion.
         * @param {File} backgroundImage The uploaded background image file
         * @param {File} pieceImage The uploaded puzzle piece image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completePuzzleCaptcha(backgroundImage, pieceImage, options) {
            return localVarFp.completePuzzleCaptcha(backgroundImage, pieceImage, options).then((request) => request(axios, basePath));
        },
        /**
         * The shapes captcha requires just one image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/threed.png\" alt=\"Shapes Captcha Example\" width=\"480\" />  ## Usage  The solution to the shapes captcha are two points that need to be clicked. To use it in the GUI, convert the proportions to pixel values based on the image size.  The `points` are returned as `x` and `y` proportions (0-1) of the width and height of the source image. The captcha image selector is `.captcha-verify-image`
         * @param {File} shapesCaptchaImage The uploaded image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeShapesCaptcha(shapesCaptchaImage, options) {
            return localVarFp.completeShapesCaptcha(shapesCaptchaImage, options).then((request) => request(axios, basePath));
        },
        /**
         * The whirl captcha requires two images: the outer image and the inner image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/rotate.png\" alt=\"Whirl Captcha Example\" width=\"480\" />  ## Usage  The solution to the whirl captcha is an angle from 0-360. To use it in the GUI, it must be converted to a slider distance:  `px = ((sidebar_length - icon_length) * angle) / 360`  - `sidebar_length` is the width of `.captcha_verify_slide--slidebar` - `icon_length` is the width of `.secsdk-captcha-drag-icon`
         * @param {File} outerImage The outer image file
         * @param {File} innerImage The inner image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeWhirlCaptcha(outerImage, innerImage, options) {
            return localVarFp.completeWhirlCaptcha(outerImage, innerImage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the rate limits for the provided API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCaptchaCredits(options) {
            return localVarFp.retrieveCaptchaCredits(options).then((request) => request(axios, basePath));
        },
    };
};
exports.CaptchasApiFactory = CaptchasApiFactory;
/**
 * CaptchasApi - object-oriented interface
 * @export
 * @class CaptchasApi
 * @extends {BaseAPI}
 */
class CaptchasApi extends base_1.BaseAPI {
    /**
     * ## âš ï¸ Warning: Requires Business plan or higher  The icons captcha requires just one image & a prompt string.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/icon.png\" alt=\"Icons Captcha Example\" width=\"480\" />  ## Usage  The `prompt` is the text prompt provided by TikTok. The Icon captcha solution is provided as a list of points, where each point marks a location on the image that needs to be clicked. These points are expressed as ratios relative to the image\'s width and height. A point of (0.0, 0.0) corresponds to the imageâ€™s upper-left corner, while (1.0, 1.0) represents the lower-right corner. For reference, (0.5, 0.5) sits at the exact center.  The captcha image selector is `.captcha-verify-image`
     * @param {string} prompt The prompt string provided by TikTok
     * @param {File} captchaImage The uploaded image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaptchasApi
     */
    completeIconCaptcha(prompt, captchaImage, options) {
        return (0, exports.CaptchasApiFp)(this.configuration).completeIconCaptcha(prompt, captchaImage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The puzzle captcha requires two images  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/puzzle.png\" alt=\"Puzzle Piece Example\" width=\"480\" />  ## Usage  The solution to the puzzle captcha is the distance to move the slider to fit the puzzle piece into the background.  The `backgroundImage` is the full background image with the missing piece. The `pieceImage` is the small puzzle piece that needs to be fit into the background.  The captcha image selectors are: - Background: `.captcha-verify-image` - Piece: `#captcha-verify-image ~ div.cap-absolute > img`  The solution is the `x` proportion (0-1) of the width of the background image where the piece fits. It is 1:1 with the slider distance proportion.
     * @param {File} backgroundImage The uploaded background image file
     * @param {File} pieceImage The uploaded puzzle piece image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaptchasApi
     */
    completePuzzleCaptcha(backgroundImage, pieceImage, options) {
        return (0, exports.CaptchasApiFp)(this.configuration).completePuzzleCaptcha(backgroundImage, pieceImage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The shapes captcha requires just one image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/threed.png\" alt=\"Shapes Captcha Example\" width=\"480\" />  ## Usage  The solution to the shapes captcha are two points that need to be clicked. To use it in the GUI, convert the proportions to pixel values based on the image size.  The `points` are returned as `x` and `y` proportions (0-1) of the width and height of the source image. The captcha image selector is `.captcha-verify-image`
     * @param {File} shapesCaptchaImage The uploaded image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaptchasApi
     */
    completeShapesCaptcha(shapesCaptchaImage, options) {
        return (0, exports.CaptchasApiFp)(this.configuration).completeShapesCaptcha(shapesCaptchaImage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The whirl captcha requires two images: the outer image and the inner image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/rotate.png\" alt=\"Whirl Captcha Example\" width=\"480\" />  ## Usage  The solution to the whirl captcha is an angle from 0-360. To use it in the GUI, it must be converted to a slider distance:  `px = ((sidebar_length - icon_length) * angle) / 360`  - `sidebar_length` is the width of `.captcha_verify_slide--slidebar` - `icon_length` is the width of `.secsdk-captcha-drag-icon`
     * @param {File} outerImage The outer image file
     * @param {File} innerImage The inner image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaptchasApi
     */
    completeWhirlCaptcha(outerImage, innerImage, options) {
        return (0, exports.CaptchasApiFp)(this.configuration).completeWhirlCaptcha(outerImage, innerImage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the rate limits for the provided API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaptchasApi
     */
    retrieveCaptchaCredits(options) {
        return (0, exports.CaptchasApiFp)(this.configuration).retrieveCaptchaCredits(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CaptchasApi = CaptchasApi;
/**
 * TikTokLIVEApi - axios parameter creator
 * @export
 */
const TikTokLIVEApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [sessionId] Cookie - The account session ID from TikTok web
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {SoaxProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchWebcastURL: async (client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options = {}) => {
            const localVarPath = `/webcast/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }
            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }
            if (uniqueId !== undefined) {
                localVarQueryParameter['unique_id'] = uniqueId;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }
            if (userAgent !== undefined) {
                localVarQueryParameter['user_agent'] = userAgent;
            }
            if (ttTargetIdc !== undefined) {
                localVarQueryParameter['tt_target_idc'] = ttTargetIdc;
            }
            if (clientEnter !== undefined) {
                localVarQueryParameter['client_enter'] = clientEnter;
            }
            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }
            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimits: async (options = {}) => {
            const localVarPath = `/webcast/rate_limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Premium Route - A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
         * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBulkLiveCheck: async (retrieveBulkLiveCheckPayload, options = {}) => {
            // verify required parameter 'retrieveBulkLiveCheckPayload' is not null or undefined
            (0, common_1.assertParamExists)('retrieveBulkLiveCheck', 'retrieveBulkLiveCheckPayload', retrieveBulkLiveCheckPayload);
            const localVarPath = `/webcast/bulk_live_check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(retrieveBulkLiveCheckPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve TikTok Live Room Gift List
         * @param {string} roomId The room ID of the TikTok LIVE session
         * @param {string} [webcastLanguage] Webcast language for locale-based fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGiftInfo: async (roomId, webcastLanguage, options = {}) => {
            // verify required parameter 'roomId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveGiftInfo', 'roomId', roomId);
            const localVarPath = `/webcast/gift_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }
            if (webcastLanguage !== undefined) {
                localVarQueryParameter['webcast_language'] = webcastLanguage;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomCover: async (uniqueId, options = {}) => {
            // verify required parameter 'uniqueId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveRoomCover', 'uniqueId', uniqueId);
            const localVarPath = `/webcast/room_cover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomId: async (uniqueId, options = {}) => {
            // verify required parameter 'uniqueId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveRoomId', 'uniqueId', uniqueId);
            const localVarPath = `/webcast/room_id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Premium Route - Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomInfo: async (uniqueId, options = {}) => {
            // verify required parameter 'uniqueId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveRoomInfo', 'uniqueId', uniqueId);
            const localVarPath = `/webcast/room_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomVideo: async (uniqueId, streamType, options = {}) => {
            // verify required parameter 'uniqueId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveRoomVideo', 'uniqueId', uniqueId);
            const localVarPath = `/webcast/room_video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }
            if (streamType !== undefined) {
                localVarQueryParameter['streamType'] = streamType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Premium Route - Fetch the TikTok LIVE webcast feed for a specific region. Gets a random sampling of creators for a region.
         * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebcastFeed: async (region, options = {}) => {
            // verify required parameter 'region' is not null or undefined
            (0, common_1.assertParamExists)('retrieveWebcastFeed', 'region', region);
            const localVarPath = `/webcast/feed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication jwt_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Premium Route - Retrieve TikTok LIVE rankings for a specific region.
         * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
         * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
         * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
         * @param {RetrieveWebcastRankingsRankTypeEnum} rankType The type of ranking to fetch. See documentation for more details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebcastRankings: async (region, sessionId, ttTargetIdc, rankType, options = {}) => {
            // verify required parameter 'region' is not null or undefined
            (0, common_1.assertParamExists)('retrieveWebcastRankings', 'region', region);
            // verify required parameter 'sessionId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveWebcastRankings', 'sessionId', sessionId);
            // verify required parameter 'ttTargetIdc' is not null or undefined
            (0, common_1.assertParamExists)('retrieveWebcastRankings', 'ttTargetIdc', ttTargetIdc);
            // verify required parameter 'rankType' is not null or undefined
            (0, common_1.assertParamExists)('retrieveWebcastRankings', 'rankType', rankType);
            const localVarPath = `/webcast/rankings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }
            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }
            if (ttTargetIdc !== undefined) {
                localVarQueryParameter['tt_target_idc'] = ttTargetIdc;
            }
            if (rankType !== undefined) {
                localVarQueryParameter['rank_type'] = rankType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Premium Route - Retrieve TikTok LIVE earnings for a specific user.
         * @param {string} uniqueId The unique ID (username) of the user to fetch earnings for.
         * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
         * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
         * @param {WebcastUserEarningsOutputPeriod} [period] Earnings period
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebcastUserEarnings: async (uniqueId, sessionId, ttTargetIdc, period, options = {}) => {
            // verify required parameter 'uniqueId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveWebcastUserEarnings', 'uniqueId', uniqueId);
            // verify required parameter 'sessionId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveWebcastUserEarnings', 'sessionId', sessionId);
            // verify required parameter 'ttTargetIdc' is not null or undefined
            (0, common_1.assertParamExists)('retrieveWebcastUserEarnings', 'ttTargetIdc', ttTargetIdc);
            const localVarPath = `/webcast/user_earnings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (uniqueId !== undefined) {
                localVarQueryParameter['unique_id'] = uniqueId;
            }
            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }
            if (ttTargetIdc !== undefined) {
                localVarQueryParameter['tt_target_idc'] = ttTargetIdc;
            }
            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Premium Route - Send a chat to a TikTok LIVE room.
         * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRoomChat: async (webcastRoomChatPayload, options = {}) => {
            // verify required parameter 'webcastRoomChatPayload' is not null or undefined
            (0, common_1.assertParamExists)('sendRoomChat', 'webcastRoomChatPayload', webcastRoomChatPayload);
            const localVarPath = `/webcast/chat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(webcastRoomChatPayload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {SignTikTokUrlBody} signTikTokUrlBody
         * @param {string} [client]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signWebcastUrl: async (signTikTokUrlBody, client, options = {}) => {
            // verify required parameter 'signTikTokUrlBody' is not null or undefined
            (0, common_1.assertParamExists)('signWebcastUrl', 'signTikTokUrlBody', signTikTokUrlBody);
            const localVarPath = `/webcast/sign_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key_query required
            await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
            // authentication api_key_header required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(signTikTokUrlBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TikTokLIVEApiAxiosParamCreator = TikTokLIVEApiAxiosParamCreator;
/**
 * TikTokLIVEApi - functional programming interface
 * @export
 */
const TikTokLIVEApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TikTokLIVEApiAxiosParamCreator)(configuration);
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [sessionId] Cookie - The account session ID from TikTok web
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {SoaxProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.fetchWebcastURL']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateLimits(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRateLimits(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.getRateLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Premium Route - A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
         * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveBulkLiveCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve TikTok Live Room Gift List
         * @param {string} roomId The room ID of the TikTok LIVE session
         * @param {string} [webcastLanguage] Webcast language for locale-based fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveGiftInfo(roomId, webcastLanguage, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveGiftInfo(roomId, webcastLanguage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveGiftInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomCover(uniqueId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomCover(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveRoomCover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomId(uniqueId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomId(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveRoomId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Premium Route - Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomInfo(uniqueId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomInfo(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomVideo(uniqueId, streamType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomVideo(uniqueId, streamType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveRoomVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Premium Route - Fetch the TikTok LIVE webcast feed for a specific region. Gets a random sampling of creators for a region.
         * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveWebcastFeed(region, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveWebcastFeed(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveWebcastFeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Premium Route - Retrieve TikTok LIVE rankings for a specific region.
         * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
         * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
         * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
         * @param {RetrieveWebcastRankingsRankTypeEnum} rankType The type of ranking to fetch. See documentation for more details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveWebcastRankings(region, sessionId, ttTargetIdc, rankType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveWebcastRankings(region, sessionId, ttTargetIdc, rankType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveWebcastRankings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Premium Route - Retrieve TikTok LIVE earnings for a specific user.
         * @param {string} uniqueId The unique ID (username) of the user to fetch earnings for.
         * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
         * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
         * @param {WebcastUserEarningsOutputPeriod} [period] Earnings period
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveWebcastUserEarnings(uniqueId, sessionId, ttTargetIdc, period, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveWebcastUserEarnings(uniqueId, sessionId, ttTargetIdc, period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.retrieveWebcastUserEarnings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Premium Route - Send a chat to a TikTok LIVE room.
         * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRoomChat(webcastRoomChatPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendRoomChat(webcastRoomChatPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.sendRoomChat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {SignTikTokUrlBody} signTikTokUrlBody
         * @param {string} [client]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signWebcastUrl(signTikTokUrlBody, client, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signWebcastUrl(signTikTokUrlBody, client, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TikTokLIVEApi.signWebcastUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.TikTokLIVEApiFp = TikTokLIVEApiFp;
/**
 * TikTokLIVEApi - factory interface
 * @export
 */
const TikTokLIVEApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TikTokLIVEApiFp)(configuration);
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [sessionId] Cookie - The account session ID from TikTok web
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {SoaxProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options) {
            return localVarFp.fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimits(options) {
            return localVarFp.getRateLimits(options).then((request) => request(axios, basePath));
        },
        /**
         * Premium Route - A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
         * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options) {
            return localVarFp.retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve TikTok Live Room Gift List
         * @param {string} roomId The room ID of the TikTok LIVE session
         * @param {string} [webcastLanguage] Webcast language for locale-based fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGiftInfo(roomId, webcastLanguage, options) {
            return localVarFp.retrieveGiftInfo(roomId, webcastLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomCover(uniqueId, options) {
            return localVarFp.retrieveRoomCover(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomId(uniqueId, options) {
            return localVarFp.retrieveRoomId(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Premium Route - Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomInfo(uniqueId, options) {
            return localVarFp.retrieveRoomInfo(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomVideo(uniqueId, streamType, options) {
            return localVarFp.retrieveRoomVideo(uniqueId, streamType, options).then((request) => request(axios, basePath));
        },
        /**
         * Premium Route - Fetch the TikTok LIVE webcast feed for a specific region. Gets a random sampling of creators for a region.
         * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebcastFeed(region, options) {
            return localVarFp.retrieveWebcastFeed(region, options).then((request) => request(axios, basePath));
        },
        /**
         * Premium Route - Retrieve TikTok LIVE rankings for a specific region.
         * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
         * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
         * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
         * @param {RetrieveWebcastRankingsRankTypeEnum} rankType The type of ranking to fetch. See documentation for more details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebcastRankings(region, sessionId, ttTargetIdc, rankType, options) {
            return localVarFp.retrieveWebcastRankings(region, sessionId, ttTargetIdc, rankType, options).then((request) => request(axios, basePath));
        },
        /**
         * Premium Route - Retrieve TikTok LIVE earnings for a specific user.
         * @param {string} uniqueId The unique ID (username) of the user to fetch earnings for.
         * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
         * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
         * @param {WebcastUserEarningsOutputPeriod} [period] Earnings period
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebcastUserEarnings(uniqueId, sessionId, ttTargetIdc, period, options) {
            return localVarFp.retrieveWebcastUserEarnings(uniqueId, sessionId, ttTargetIdc, period, options).then((request) => request(axios, basePath));
        },
        /**
         * Premium Route - Send a chat to a TikTok LIVE room.
         * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRoomChat(webcastRoomChatPayload, options) {
            return localVarFp.sendRoomChat(webcastRoomChatPayload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SignTikTokUrlBody} signTikTokUrlBody
         * @param {string} [client]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signWebcastUrl(signTikTokUrlBody, client, options) {
            return localVarFp.signWebcastUrl(signTikTokUrlBody, client, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TikTokLIVEApiFactory = TikTokLIVEApiFactory;
/**
 * TikTokLIVEApi - object-oriented interface
 * @export
 * @class TikTokLIVEApi
 * @extends {BaseAPI}
 */
class TikTokLIVEApi extends base_1.BaseAPI {
    /**
     * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
     * @param {string} [client] The client library identifier. Used for metrics.
     * @param {string} [roomId] The room ID to fetch the Webcast URL for.
     * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
     * @param {string} [cursor] Starting cursor for the webcast connection, if any
     * @param {string} [sessionId] Cookie - The account session ID from TikTok web
     * @param {string} [userAgent] Override the user agent used for signing and fetching
     * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
     * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
     * @param {SoaxProxyRegion} [country] Country code to make the request from.
     * @param {WebcastFetchPlatform} [platform] Platform to connect with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    getRateLimits(options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).getRateLimits(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Premium Route - A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
     * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve TikTok Live Room Gift List
     * @param {string} roomId The room ID of the TikTok LIVE session
     * @param {string} [webcastLanguage] Webcast language for locale-based fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveGiftInfo(roomId, webcastLanguage, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveGiftInfo(roomId, webcastLanguage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveRoomCover(uniqueId, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveRoomCover(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch Room ID for a given uniqueId & whether that user is live.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveRoomId(uniqueId, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveRoomId(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Premium Route - Retrieve TikTok Live Room Information
     * @param {string} uniqueId The unique identifier for the TikTok user or room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveRoomInfo(uniqueId, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveRoomInfo(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch TikTok LIVE Stream video given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
     * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveRoomVideo(uniqueId, streamType, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveRoomVideo(uniqueId, streamType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Premium Route - Fetch the TikTok LIVE webcast feed for a specific region. Gets a random sampling of creators for a region.
     * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveWebcastFeed(region, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveWebcastFeed(region, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Premium Route - Retrieve TikTok LIVE rankings for a specific region.
     * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
     * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
     * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
     * @param {RetrieveWebcastRankingsRankTypeEnum} rankType The type of ranking to fetch. See documentation for more details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveWebcastRankings(region, sessionId, ttTargetIdc, rankType, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveWebcastRankings(region, sessionId, ttTargetIdc, rankType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Premium Route - Retrieve TikTok LIVE earnings for a specific user.
     * @param {string} uniqueId The unique ID (username) of the user to fetch earnings for.
     * @param {string} sessionId The session ID cookie from TikTok, used to access the feed.
     * @param {string} ttTargetIdc The tt-target-idc cookie from TikTok, used to access the feed.
     * @param {WebcastUserEarningsOutputPeriod} [period] Earnings period
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    retrieveWebcastUserEarnings(uniqueId, sessionId, ttTargetIdc, period, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).retrieveWebcastUserEarnings(uniqueId, sessionId, ttTargetIdc, period, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Premium Route - Send a chat to a TikTok LIVE room.
     * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    sendRoomChat(webcastRoomChatPayload, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).sendRoomChat(webcastRoomChatPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {SignTikTokUrlBody} signTikTokUrlBody
     * @param {string} [client]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    signWebcastUrl(signTikTokUrlBody, client, options) {
        return (0, exports.TikTokLIVEApiFp)(this.configuration).signWebcastUrl(signTikTokUrlBody, client, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TikTokLIVEApi = TikTokLIVEApi;
/**
 * @export
 */
exports.RetrieveWebcastRankingsRankTypeEnum = {
    FansTeamRank: 'FANS_TEAM_RANK',
    DailyRank: 'DAILY_RANK'
};
//# sourceMappingURL=api.js.map